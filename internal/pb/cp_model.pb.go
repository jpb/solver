// Copyright 2010-2024 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Proto describing a general Constraint Programming (CP) problem.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.33.0
// 	protoc        v4.24.4
// source: cp_model.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// The status returned by a solver trying to solve a CpModelProto.
type CpSolverStatus int32

const (
	// The status of the model is still unknown. A search limit has been reached
	// before any of the statuses below could be determined.
	CpSolverStatus_UNKNOWN CpSolverStatus = 0
	// The given CpModelProto didn't pass the validation step. You can get a
	// detailed error by calling ValidateCpModel(model_proto).
	CpSolverStatus_MODEL_INVALID CpSolverStatus = 1
	// A feasible solution has been found. But the search was stopped before we
	// could prove optimality or before we enumerated all solutions of a
	// feasibility problem (if asked).
	CpSolverStatus_FEASIBLE CpSolverStatus = 2
	// The problem has been proven infeasible.
	CpSolverStatus_INFEASIBLE CpSolverStatus = 3
	// An optimal feasible solution has been found.
	//
	// More generally, this status represent a success. So we also return OPTIMAL
	// if we find a solution for a pure feasiblity problem or if a gap limit has
	// been specified and we return a solution within this limit. In the case
	// where we need to return all the feasible solution, this status will only be
	// returned if we enumerated all of them; If we stopped before, we will return
	// FEASIBLE.
	CpSolverStatus_OPTIMAL CpSolverStatus = 4
)

// Enum value maps for CpSolverStatus.
var (
	CpSolverStatus_name = map[int32]string{
		0: "UNKNOWN",
		1: "MODEL_INVALID",
		2: "FEASIBLE",
		3: "INFEASIBLE",
		4: "OPTIMAL",
	}
	CpSolverStatus_value = map[string]int32{
		"UNKNOWN":       0,
		"MODEL_INVALID": 1,
		"FEASIBLE":      2,
		"INFEASIBLE":    3,
		"OPTIMAL":       4,
	}
)

func (x CpSolverStatus) Enum() *CpSolverStatus {
	p := new(CpSolverStatus)
	*p = x
	return p
}

func (x CpSolverStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CpSolverStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[0].Descriptor()
}

func (CpSolverStatus) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[0]
}

func (x CpSolverStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CpSolverStatus.Descriptor instead.
func (CpSolverStatus) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{0}
}

// The order in which the variables (resp. affine expression) above should be
// considered. Note that only variables that are not already fixed are
// considered.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_VariableSelectionStrategy int32

const (
	DecisionStrategyProto_CHOOSE_FIRST           DecisionStrategyProto_VariableSelectionStrategy = 0
	DecisionStrategyProto_CHOOSE_LOWEST_MIN      DecisionStrategyProto_VariableSelectionStrategy = 1
	DecisionStrategyProto_CHOOSE_HIGHEST_MAX     DecisionStrategyProto_VariableSelectionStrategy = 2
	DecisionStrategyProto_CHOOSE_MIN_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 3
	DecisionStrategyProto_CHOOSE_MAX_DOMAIN_SIZE DecisionStrategyProto_VariableSelectionStrategy = 4
)

// Enum value maps for DecisionStrategyProto_VariableSelectionStrategy.
var (
	DecisionStrategyProto_VariableSelectionStrategy_name = map[int32]string{
		0: "CHOOSE_FIRST",
		1: "CHOOSE_LOWEST_MIN",
		2: "CHOOSE_HIGHEST_MAX",
		3: "CHOOSE_MIN_DOMAIN_SIZE",
		4: "CHOOSE_MAX_DOMAIN_SIZE",
	}
	DecisionStrategyProto_VariableSelectionStrategy_value = map[string]int32{
		"CHOOSE_FIRST":           0,
		"CHOOSE_LOWEST_MIN":      1,
		"CHOOSE_HIGHEST_MAX":     2,
		"CHOOSE_MIN_DOMAIN_SIZE": 3,
		"CHOOSE_MAX_DOMAIN_SIZE": 4,
	}
)

func (x DecisionStrategyProto_VariableSelectionStrategy) Enum() *DecisionStrategyProto_VariableSelectionStrategy {
	p := new(DecisionStrategyProto_VariableSelectionStrategy)
	*p = x
	return p
}

func (x DecisionStrategyProto_VariableSelectionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DecisionStrategyProto_VariableSelectionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[1].Descriptor()
}

func (DecisionStrategyProto_VariableSelectionStrategy) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[1]
}

func (x DecisionStrategyProto_VariableSelectionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DecisionStrategyProto_VariableSelectionStrategy.Descriptor instead.
func (DecisionStrategyProto_VariableSelectionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21, 0}
}

// Once a variable (resp. affine expression) has been chosen, this enum
// describe what decision is taken on its domain.
//
// TODO(user): extend as needed.
type DecisionStrategyProto_DomainReductionStrategy int32

const (
	DecisionStrategyProto_SELECT_MIN_VALUE    DecisionStrategyProto_DomainReductionStrategy = 0
	DecisionStrategyProto_SELECT_MAX_VALUE    DecisionStrategyProto_DomainReductionStrategy = 1
	DecisionStrategyProto_SELECT_LOWER_HALF   DecisionStrategyProto_DomainReductionStrategy = 2
	DecisionStrategyProto_SELECT_UPPER_HALF   DecisionStrategyProto_DomainReductionStrategy = 3
	DecisionStrategyProto_SELECT_MEDIAN_VALUE DecisionStrategyProto_DomainReductionStrategy = 4
)

// Enum value maps for DecisionStrategyProto_DomainReductionStrategy.
var (
	DecisionStrategyProto_DomainReductionStrategy_name = map[int32]string{
		0: "SELECT_MIN_VALUE",
		1: "SELECT_MAX_VALUE",
		2: "SELECT_LOWER_HALF",
		3: "SELECT_UPPER_HALF",
		4: "SELECT_MEDIAN_VALUE",
	}
	DecisionStrategyProto_DomainReductionStrategy_value = map[string]int32{
		"SELECT_MIN_VALUE":    0,
		"SELECT_MAX_VALUE":    1,
		"SELECT_LOWER_HALF":   2,
		"SELECT_UPPER_HALF":   3,
		"SELECT_MEDIAN_VALUE": 4,
	}
)

func (x DecisionStrategyProto_DomainReductionStrategy) Enum() *DecisionStrategyProto_DomainReductionStrategy {
	p := new(DecisionStrategyProto_DomainReductionStrategy)
	*p = x
	return p
}

func (x DecisionStrategyProto_DomainReductionStrategy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DecisionStrategyProto_DomainReductionStrategy) Descriptor() protoreflect.EnumDescriptor {
	return file_cp_model_proto_enumTypes[2].Descriptor()
}

func (DecisionStrategyProto_DomainReductionStrategy) Type() protoreflect.EnumType {
	return &file_cp_model_proto_enumTypes[2]
}

func (x DecisionStrategyProto_DomainReductionStrategy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DecisionStrategyProto_DomainReductionStrategy.Descriptor instead.
func (DecisionStrategyProto_DomainReductionStrategy) EnumDescriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21, 1}
}

// An integer variable.
//
// It will be referred to by an int32 corresponding to its index in a
// CpModelProto variables field.
//
// Depending on the context, a reference to a variable whose domain is in [0, 1]
// can also be seen as a Boolean that will be true if the variable value is 1
// and false if it is 0. When used in this context, the field name will always
// contain the word "literal".
//
// Negative reference (advanced usage): to simplify the creation of a model and
// for efficiency reasons, all the "literal" or "variable" fields can also
// contain a negative index. A negative index i will refer to the negation of
// the integer variable at index -i -1 or to NOT the literal at the same index.
//
// Ex: A variable index 4 will refer to the integer variable model.variables(4)
// and an index of -5 will refer to the negation of the same variable. A literal
// index 4 will refer to the logical fact that model.variable(4) == 1 and a
// literal index of -5 will refer to the logical fact model.variable(4) == 0.
type IntegerVariableProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The variable domain given as a sorted list of n disjoint intervals
	// [min, max] and encoded as [min_0, max_0,  ..., min_{n-1}, max_{n-1}].
	//
	// The most common example being just [min, max].
	// If min == max, then this is a constant variable.
	//
	// We have:
	//   - domain_size() is always even.
	//   - min == domain.front();
	//   - max == domain.back();
	//   - for all i < n   :      min_i <= max_i
	//   - for all i < n-1 :  max_i + 1 < min_{i+1}.
	//
	// Note that we check at validation that a variable domain is small enough so
	// that we don't run into integer overflow in our algorithms. Because of that,
	// you cannot just have "unbounded" variable like [0, kint64max] and should
	// try to specify tighter domains.
	Domain []int64 `protobuf:"varint,2,rep,packed,name=domain,proto3" json:"domain,omitempty"`
}

func (x *IntegerVariableProto) Reset() {
	*x = IntegerVariableProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntegerVariableProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntegerVariableProto) ProtoMessage() {}

func (x *IntegerVariableProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntegerVariableProto.ProtoReflect.Descriptor instead.
func (*IntegerVariableProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{0}
}

func (x *IntegerVariableProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IntegerVariableProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

// Argument of the constraints of the form OP(literals).
type BoolArgumentProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Literals []int32 `protobuf:"varint,1,rep,packed,name=literals,proto3" json:"literals,omitempty"`
}

func (x *BoolArgumentProto) Reset() {
	*x = BoolArgumentProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *BoolArgumentProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BoolArgumentProto) ProtoMessage() {}

func (x *BoolArgumentProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BoolArgumentProto.ProtoReflect.Descriptor instead.
func (*BoolArgumentProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{1}
}

func (x *BoolArgumentProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

// Some constraints supports linear expression instead of just using a reference
// to a variable. This is especially useful during presolve to reduce the model
// size.
type LinearExpressionProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	Offset int64   `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (x *LinearExpressionProto) Reset() {
	*x = LinearExpressionProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearExpressionProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearExpressionProto) ProtoMessage() {}

func (x *LinearExpressionProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearExpressionProto.ProtoReflect.Descriptor instead.
func (*LinearExpressionProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{2}
}

func (x *LinearExpressionProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *LinearExpressionProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *LinearExpressionProto) GetOffset() int64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

type LinearArgumentProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Target *LinearExpressionProto   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	Exprs  []*LinearExpressionProto `protobuf:"bytes,2,rep,name=exprs,proto3" json:"exprs,omitempty"`
}

func (x *LinearArgumentProto) Reset() {
	*x = LinearArgumentProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearArgumentProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearArgumentProto) ProtoMessage() {}

func (x *LinearArgumentProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearArgumentProto.ProtoReflect.Descriptor instead.
func (*LinearArgumentProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{3}
}

func (x *LinearArgumentProto) GetTarget() *LinearExpressionProto {
	if x != nil {
		return x.Target
	}
	return nil
}

func (x *LinearArgumentProto) GetExprs() []*LinearExpressionProto {
	if x != nil {
		return x.Exprs
	}
	return nil
}

// All affine expressions must take different values.
type AllDifferentConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Exprs []*LinearExpressionProto `protobuf:"bytes,1,rep,name=exprs,proto3" json:"exprs,omitempty"`
}

func (x *AllDifferentConstraintProto) Reset() {
	*x = AllDifferentConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AllDifferentConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllDifferentConstraintProto) ProtoMessage() {}

func (x *AllDifferentConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllDifferentConstraintProto.ProtoReflect.Descriptor instead.
func (*AllDifferentConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{4}
}

func (x *AllDifferentConstraintProto) GetExprs() []*LinearExpressionProto {
	if x != nil {
		return x.Exprs
	}
	return nil
}

// The linear sum vars[i] * coeffs[i] must fall in the given domain. The domain
// has the same format as the one in IntegerVariableProto.
//
// Note that the validation code currently checks using the domain of the
// involved variables that the sum can always be computed without integer
// overflow and throws an error otherwise.
type LinearConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"` // Same size as vars.
	Domain []int64 `protobuf:"varint,3,rep,packed,name=domain,proto3" json:"domain,omitempty"`
}

func (x *LinearConstraintProto) Reset() {
	*x = LinearConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *LinearConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LinearConstraintProto) ProtoMessage() {}

func (x *LinearConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LinearConstraintProto.ProtoReflect.Descriptor instead.
func (*LinearConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{5}
}

func (x *LinearConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *LinearConstraintProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *LinearConstraintProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

// The constraint target = vars[index].
// This enforces that index takes one of the value in [0, vars_size()).
type ElementConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Index  int32   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Target int32   `protobuf:"varint,2,opt,name=target,proto3" json:"target,omitempty"`
	Vars   []int32 `protobuf:"varint,3,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *ElementConstraintProto) Reset() {
	*x = ElementConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ElementConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ElementConstraintProto) ProtoMessage() {}

func (x *ElementConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ElementConstraintProto.ProtoReflect.Descriptor instead.
func (*ElementConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{6}
}

func (x *ElementConstraintProto) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *ElementConstraintProto) GetTarget() int32 {
	if x != nil {
		return x.Target
	}
	return 0
}

func (x *ElementConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// This is not really a constraint. It is there so it can be referred by other
// constraints using this "interval" concept.
//
// IMPORTANT: For now, this constraint do not enforce any relations on the
// components, and it is up to the client to add in the model:
// - enforcement => start + size == end.
// - enforcement => size >= 0  // Only needed if size is not already >= 0.
//
// IMPORTANT: For now, we just support affine relation. We could easily
// create an intermediate variable to support full linear expression, but this
// isn't done currently.
type IntervalConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Start *LinearExpressionProto `protobuf:"bytes,4,opt,name=start,proto3" json:"start,omitempty"`
	End   *LinearExpressionProto `protobuf:"bytes,5,opt,name=end,proto3" json:"end,omitempty"`
	Size  *LinearExpressionProto `protobuf:"bytes,6,opt,name=size,proto3" json:"size,omitempty"`
}

func (x *IntervalConstraintProto) Reset() {
	*x = IntervalConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *IntervalConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IntervalConstraintProto) ProtoMessage() {}

func (x *IntervalConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IntervalConstraintProto.ProtoReflect.Descriptor instead.
func (*IntervalConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{7}
}

func (x *IntervalConstraintProto) GetStart() *LinearExpressionProto {
	if x != nil {
		return x.Start
	}
	return nil
}

func (x *IntervalConstraintProto) GetEnd() *LinearExpressionProto {
	if x != nil {
		return x.End
	}
	return nil
}

func (x *IntervalConstraintProto) GetSize() *LinearExpressionProto {
	if x != nil {
		return x.Size
	}
	return nil
}

// All the intervals (index of IntervalConstraintProto) must be disjoint. More
// formally, there must exist a sequence so that for each consecutive intervals,
// we have end_i <= start_{i+1}. In particular, intervals of size zero do matter
// for this constraint. This is also known as a disjunctive constraint in
// scheduling.
type NoOverlapConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Intervals []int32 `protobuf:"varint,1,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
}

func (x *NoOverlapConstraintProto) Reset() {
	*x = NoOverlapConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NoOverlapConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NoOverlapConstraintProto) ProtoMessage() {}

func (x *NoOverlapConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NoOverlapConstraintProto.ProtoReflect.Descriptor instead.
func (*NoOverlapConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{8}
}

func (x *NoOverlapConstraintProto) GetIntervals() []int32 {
	if x != nil {
		return x.Intervals
	}
	return nil
}

// The boxes defined by [start_x, end_x) * [start_y, end_y) cannot overlap.
// Furthermore, one box is optional if at least one of the x or y interval is
// optional.
//
// Note that the case of boxes of size zero is special. The following cases
// violate the constraint:
//   - a point box inside a box with a non zero area
//   - a line box overlapping a box with a non zero area
//   - one vertical line box crossing an horizontal line box.
type NoOverlap2DConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	XIntervals []int32 `protobuf:"varint,1,rep,packed,name=x_intervals,json=xIntervals,proto3" json:"x_intervals,omitempty"`
	YIntervals []int32 `protobuf:"varint,2,rep,packed,name=y_intervals,json=yIntervals,proto3" json:"y_intervals,omitempty"` // Same size as x_intervals.
}

func (x *NoOverlap2DConstraintProto) Reset() {
	*x = NoOverlap2DConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *NoOverlap2DConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NoOverlap2DConstraintProto) ProtoMessage() {}

func (x *NoOverlap2DConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NoOverlap2DConstraintProto.ProtoReflect.Descriptor instead.
func (*NoOverlap2DConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{9}
}

func (x *NoOverlap2DConstraintProto) GetXIntervals() []int32 {
	if x != nil {
		return x.XIntervals
	}
	return nil
}

func (x *NoOverlap2DConstraintProto) GetYIntervals() []int32 {
	if x != nil {
		return x.YIntervals
	}
	return nil
}

// The sum of the demands of the intervals at each interval point cannot exceed
// a capacity. Note that intervals are interpreted as [start, end) and as
// such intervals like [2,3) and [3,4) do not overlap for the point of view of
// this constraint. Moreover, intervals of size zero are ignored.
//
// All demands must not contain any negative value in their domains. This is
// checked at validation. The capacity can currently contains negative values,
// but it will be propagated to >= 0 right away.
type CumulativeConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Capacity  *LinearExpressionProto   `protobuf:"bytes,1,opt,name=capacity,proto3" json:"capacity,omitempty"`
	Intervals []int32                  `protobuf:"varint,2,rep,packed,name=intervals,proto3" json:"intervals,omitempty"`
	Demands   []*LinearExpressionProto `protobuf:"bytes,3,rep,name=demands,proto3" json:"demands,omitempty"` // Same size as intervals.
}

func (x *CumulativeConstraintProto) Reset() {
	*x = CumulativeConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CumulativeConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CumulativeConstraintProto) ProtoMessage() {}

func (x *CumulativeConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CumulativeConstraintProto.ProtoReflect.Descriptor instead.
func (*CumulativeConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{10}
}

func (x *CumulativeConstraintProto) GetCapacity() *LinearExpressionProto {
	if x != nil {
		return x.Capacity
	}
	return nil
}

func (x *CumulativeConstraintProto) GetIntervals() []int32 {
	if x != nil {
		return x.Intervals
	}
	return nil
}

func (x *CumulativeConstraintProto) GetDemands() []*LinearExpressionProto {
	if x != nil {
		return x.Demands
	}
	return nil
}

// Maintain a reservoir level within bounds. The water level starts at 0, and at
// any time, it must be within [min_level, max_level].
//
// If the variable active_literals[i] is true, and if the expression
// time_exprs[i] is assigned a value t, then the current level changes by
// level_changes[i] at the time t. Therefore, at any time t:
//
// sum(level_changes[i] * active_literals[i] if time_exprs[i] <= t)
//
//	in [min_level, max_level]
//
// Note that min level must be <= 0, and the max level must be >= 0. Please use
// fixed level_changes to simulate initial state.
//
// The array of boolean variables 'actives', if defined, indicates which actions
// are actually performed. If this array is not defined, then it is assumed that
// all actions will be performed.
type ReservoirConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	MinLevel  int64                    `protobuf:"varint,1,opt,name=min_level,json=minLevel,proto3" json:"min_level,omitempty"`
	MaxLevel  int64                    `protobuf:"varint,2,opt,name=max_level,json=maxLevel,proto3" json:"max_level,omitempty"`
	TimeExprs []*LinearExpressionProto `protobuf:"bytes,3,rep,name=time_exprs,json=timeExprs,proto3" json:"time_exprs,omitempty"` // affine expressions.
	// Currently, we only support constant level changes.
	LevelChanges   []*LinearExpressionProto `protobuf:"bytes,6,rep,name=level_changes,json=levelChanges,proto3" json:"level_changes,omitempty"` // affine expressions.
	ActiveLiterals []int32                  `protobuf:"varint,5,rep,packed,name=active_literals,json=activeLiterals,proto3" json:"active_literals,omitempty"`
}

func (x *ReservoirConstraintProto) Reset() {
	*x = ReservoirConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ReservoirConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReservoirConstraintProto) ProtoMessage() {}

func (x *ReservoirConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReservoirConstraintProto.ProtoReflect.Descriptor instead.
func (*ReservoirConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{11}
}

func (x *ReservoirConstraintProto) GetMinLevel() int64 {
	if x != nil {
		return x.MinLevel
	}
	return 0
}

func (x *ReservoirConstraintProto) GetMaxLevel() int64 {
	if x != nil {
		return x.MaxLevel
	}
	return 0
}

func (x *ReservoirConstraintProto) GetTimeExprs() []*LinearExpressionProto {
	if x != nil {
		return x.TimeExprs
	}
	return nil
}

func (x *ReservoirConstraintProto) GetLevelChanges() []*LinearExpressionProto {
	if x != nil {
		return x.LevelChanges
	}
	return nil
}

func (x *ReservoirConstraintProto) GetActiveLiterals() []int32 {
	if x != nil {
		return x.ActiveLiterals
	}
	return nil
}

// The circuit constraint is defined on a graph where the arc presence are
// controlled by literals. Each arc is given by an index in the
// tails/heads/literals lists that must have the same size.
//
// For now, we ignore node indices with no incident arc. All the other nodes
// must have exactly one incoming and one outgoing selected arc (i.e. literal at
// true). All the selected arcs that are not self-loops must form a single
// circuit. Note that multi-arcs are allowed, but only one of them will be true
// at the same time. Multi-self loop are disallowed though.
type CircuitConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tails    []int32 `protobuf:"varint,3,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads    []int32 `protobuf:"varint,4,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals []int32 `protobuf:"varint,5,rep,packed,name=literals,proto3" json:"literals,omitempty"`
}

func (x *CircuitConstraintProto) Reset() {
	*x = CircuitConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CircuitConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CircuitConstraintProto) ProtoMessage() {}

func (x *CircuitConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CircuitConstraintProto.ProtoReflect.Descriptor instead.
func (*CircuitConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{12}
}

func (x *CircuitConstraintProto) GetTails() []int32 {
	if x != nil {
		return x.Tails
	}
	return nil
}

func (x *CircuitConstraintProto) GetHeads() []int32 {
	if x != nil {
		return x.Heads
	}
	return nil
}

func (x *CircuitConstraintProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

// The "VRP" (Vehicle Routing Problem) constraint.
//
// The direct graph where arc #i (from tails[i] to head[i]) is present iff
// literals[i] is true must satisfy this set of properties:
// - #incoming arcs == 1 except for node 0.
// - #outgoing arcs == 1 except for node 0.
// - for node zero, #incoming arcs == #outgoing arcs.
// - There are no duplicate arcs.
// - Self-arcs are allowed except for node 0.
// - There is no cycle in this graph, except through node 0.
//
// Note: Currently this constraint expect all the nodes in [0, num_nodes) to
// have at least one incident arc. The model will be considered invalid if it
// is not the case. You can add self-arc fixed to one to ignore some nodes if
// needed.
//
// TODO(user): It is probably possible to generalize this constraint to a
// no-cycle in a general graph, or a no-cycle with sum incoming <= 1 and sum
// outgoing <= 1 (more efficient implementation). On the other hand, having this
// specific constraint allow us to add specific "cuts" to a VRP problem.
type RoutesConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Tails    []int32 `protobuf:"varint,1,rep,packed,name=tails,proto3" json:"tails,omitempty"`
	Heads    []int32 `protobuf:"varint,2,rep,packed,name=heads,proto3" json:"heads,omitempty"`
	Literals []int32 `protobuf:"varint,3,rep,packed,name=literals,proto3" json:"literals,omitempty"`
	// EXPERIMENTAL. The demands for each node, and the maximum capacity for each
	// route. Note that this is currently only used for the LP relaxation and one
	// need to add the corresponding constraint to enforce this outside of the LP.
	//
	// TODO(user): Ideally, we should be able to extract any dimension like these
	// (i.e. capacity, route_length, etc..) automatically from the encoding. The
	// classical way to encode that is to have "current_capacity" variables along
	// the route and linear equations of the form:
	//
	//	arc_literal => (current_capacity_tail + demand <= current_capacity_head)
	Demands  []int32 `protobuf:"varint,4,rep,packed,name=demands,proto3" json:"demands,omitempty"`
	Capacity int64   `protobuf:"varint,5,opt,name=capacity,proto3" json:"capacity,omitempty"`
}

func (x *RoutesConstraintProto) Reset() {
	*x = RoutesConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RoutesConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoutesConstraintProto) ProtoMessage() {}

func (x *RoutesConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoutesConstraintProto.ProtoReflect.Descriptor instead.
func (*RoutesConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{13}
}

func (x *RoutesConstraintProto) GetTails() []int32 {
	if x != nil {
		return x.Tails
	}
	return nil
}

func (x *RoutesConstraintProto) GetHeads() []int32 {
	if x != nil {
		return x.Heads
	}
	return nil
}

func (x *RoutesConstraintProto) GetLiterals() []int32 {
	if x != nil {
		return x.Literals
	}
	return nil
}

func (x *RoutesConstraintProto) GetDemands() []int32 {
	if x != nil {
		return x.Demands
	}
	return nil
}

func (x *RoutesConstraintProto) GetCapacity() int64 {
	if x != nil {
		return x.Capacity
	}
	return 0
}

// The values of the n-tuple formed by the given variables can only be one of
// the listed n-tuples in values. The n-tuples are encoded in a flattened way:
//
//	[tuple0_v0, tuple0_v1, ..., tuple0_v{n-1}, tuple1_v0, ...].
type TableConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values []int64 `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
	// If true, the meaning is "negated", that is we forbid any of the given
	// tuple from a feasible assignment.
	Negated bool `protobuf:"varint,3,opt,name=negated,proto3" json:"negated,omitempty"`
}

func (x *TableConstraintProto) Reset() {
	*x = TableConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *TableConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TableConstraintProto) ProtoMessage() {}

func (x *TableConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TableConstraintProto.ProtoReflect.Descriptor instead.
func (*TableConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{14}
}

func (x *TableConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *TableConstraintProto) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

func (x *TableConstraintProto) GetNegated() bool {
	if x != nil {
		return x.Negated
	}
	return false
}

// The two arrays of variable each represent a function, the second is the
// inverse of the first: f_direct[i] == j <=> f_inverse[j] == i.
type InverseConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	FDirect  []int32 `protobuf:"varint,1,rep,packed,name=f_direct,json=fDirect,proto3" json:"f_direct,omitempty"`
	FInverse []int32 `protobuf:"varint,2,rep,packed,name=f_inverse,json=fInverse,proto3" json:"f_inverse,omitempty"`
}

func (x *InverseConstraintProto) Reset() {
	*x = InverseConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *InverseConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InverseConstraintProto) ProtoMessage() {}

func (x *InverseConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InverseConstraintProto.ProtoReflect.Descriptor instead.
func (*InverseConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{15}
}

func (x *InverseConstraintProto) GetFDirect() []int32 {
	if x != nil {
		return x.FDirect
	}
	return nil
}

func (x *InverseConstraintProto) GetFInverse() []int32 {
	if x != nil {
		return x.FInverse
	}
	return nil
}

// This constraint forces a sequence of variables to be accepted by an
// automaton.
type AutomatonConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A state is identified by a non-negative number. It is preferable to keep
	// all the states dense in says [0, num_states). The automaton starts at
	// starting_state and must finish in any of the final states.
	StartingState int64   `protobuf:"varint,2,opt,name=starting_state,json=startingState,proto3" json:"starting_state,omitempty"`
	FinalStates   []int64 `protobuf:"varint,3,rep,packed,name=final_states,json=finalStates,proto3" json:"final_states,omitempty"`
	// List of transitions (all 3 vectors have the same size). Both tail and head
	// are states, label is any variable value. No two outgoing transitions from
	// the same state can have the same label.
	TransitionTail  []int64 `protobuf:"varint,4,rep,packed,name=transition_tail,json=transitionTail,proto3" json:"transition_tail,omitempty"`
	TransitionHead  []int64 `protobuf:"varint,5,rep,packed,name=transition_head,json=transitionHead,proto3" json:"transition_head,omitempty"`
	TransitionLabel []int64 `protobuf:"varint,6,rep,packed,name=transition_label,json=transitionLabel,proto3" json:"transition_label,omitempty"`
	// The sequence of variables. The automaton is ran for vars_size() "steps" and
	// the value of vars[i] corresponds to the transition label at step i.
	Vars []int32 `protobuf:"varint,7,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *AutomatonConstraintProto) Reset() {
	*x = AutomatonConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *AutomatonConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AutomatonConstraintProto) ProtoMessage() {}

func (x *AutomatonConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AutomatonConstraintProto.ProtoReflect.Descriptor instead.
func (*AutomatonConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{16}
}

func (x *AutomatonConstraintProto) GetStartingState() int64 {
	if x != nil {
		return x.StartingState
	}
	return 0
}

func (x *AutomatonConstraintProto) GetFinalStates() []int64 {
	if x != nil {
		return x.FinalStates
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionTail() []int64 {
	if x != nil {
		return x.TransitionTail
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionHead() []int64 {
	if x != nil {
		return x.TransitionHead
	}
	return nil
}

func (x *AutomatonConstraintProto) GetTransitionLabel() []int64 {
	if x != nil {
		return x.TransitionLabel
	}
	return nil
}

func (x *AutomatonConstraintProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// A list of variables, without any semantics.
type ListOfVariablesProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
}

func (x *ListOfVariablesProto) Reset() {
	*x = ListOfVariablesProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListOfVariablesProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListOfVariablesProto) ProtoMessage() {}

func (x *ListOfVariablesProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListOfVariablesProto.ProtoReflect.Descriptor instead.
func (*ListOfVariablesProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{17}
}

func (x *ListOfVariablesProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

// Next id: 31
type ConstraintProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The constraint will be enforced iff all literals listed here are true. If
	// this is empty, then the constraint will always be enforced. An enforced
	// constraint must be satisfied, and an un-enforced one will simply be
	// ignored.
	//
	// This is also called half-reification. To have an equivalence between a
	// literal and a constraint (full reification), one must add both a constraint
	// (controlled by a literal l) and its negation (controlled by the negation of
	// l).
	//
	// Important: as of September 2018, only a few constraint support enforcement:
	// - bool_or, bool_and, linear: fully supported.
	// - interval: only support a single enforcement literal.
	// - other: no support (but can be added on a per-demand basis).
	EnforcementLiteral []int32 `protobuf:"varint,2,rep,packed,name=enforcement_literal,json=enforcementLiteral,proto3" json:"enforcement_literal,omitempty"`
	// The actual constraint with its arguments.
	//
	// Types that are assignable to Constraint:
	//
	//	*ConstraintProto_BoolOr
	//	*ConstraintProto_BoolAnd
	//	*ConstraintProto_AtMostOne
	//	*ConstraintProto_ExactlyOne
	//	*ConstraintProto_BoolXor
	//	*ConstraintProto_IntDiv
	//	*ConstraintProto_IntMod
	//	*ConstraintProto_IntProd
	//	*ConstraintProto_LinMax
	//	*ConstraintProto_Linear
	//	*ConstraintProto_AllDiff
	//	*ConstraintProto_Element
	//	*ConstraintProto_Circuit
	//	*ConstraintProto_Routes
	//	*ConstraintProto_Table
	//	*ConstraintProto_Automaton
	//	*ConstraintProto_Inverse
	//	*ConstraintProto_Reservoir
	//	*ConstraintProto_Interval
	//	*ConstraintProto_NoOverlap
	//	*ConstraintProto_NoOverlap_2D
	//	*ConstraintProto_Cumulative
	//	*ConstraintProto_DummyConstraint
	Constraint isConstraintProto_Constraint `protobuf_oneof:"constraint"`
}

func (x *ConstraintProto) Reset() {
	*x = ConstraintProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ConstraintProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConstraintProto) ProtoMessage() {}

func (x *ConstraintProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConstraintProto.ProtoReflect.Descriptor instead.
func (*ConstraintProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{18}
}

func (x *ConstraintProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ConstraintProto) GetEnforcementLiteral() []int32 {
	if x != nil {
		return x.EnforcementLiteral
	}
	return nil
}

func (m *ConstraintProto) GetConstraint() isConstraintProto_Constraint {
	if m != nil {
		return m.Constraint
	}
	return nil
}

func (x *ConstraintProto) GetBoolOr() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolOr); ok {
		return x.BoolOr
	}
	return nil
}

func (x *ConstraintProto) GetBoolAnd() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolAnd); ok {
		return x.BoolAnd
	}
	return nil
}

func (x *ConstraintProto) GetAtMostOne() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_AtMostOne); ok {
		return x.AtMostOne
	}
	return nil
}

func (x *ConstraintProto) GetExactlyOne() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_ExactlyOne); ok {
		return x.ExactlyOne
	}
	return nil
}

func (x *ConstraintProto) GetBoolXor() *BoolArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_BoolXor); ok {
		return x.BoolXor
	}
	return nil
}

func (x *ConstraintProto) GetIntDiv() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntDiv); ok {
		return x.IntDiv
	}
	return nil
}

func (x *ConstraintProto) GetIntMod() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntMod); ok {
		return x.IntMod
	}
	return nil
}

func (x *ConstraintProto) GetIntProd() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_IntProd); ok {
		return x.IntProd
	}
	return nil
}

func (x *ConstraintProto) GetLinMax() *LinearArgumentProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_LinMax); ok {
		return x.LinMax
	}
	return nil
}

func (x *ConstraintProto) GetLinear() *LinearConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Linear); ok {
		return x.Linear
	}
	return nil
}

func (x *ConstraintProto) GetAllDiff() *AllDifferentConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_AllDiff); ok {
		return x.AllDiff
	}
	return nil
}

func (x *ConstraintProto) GetElement() *ElementConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Element); ok {
		return x.Element
	}
	return nil
}

func (x *ConstraintProto) GetCircuit() *CircuitConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Circuit); ok {
		return x.Circuit
	}
	return nil
}

func (x *ConstraintProto) GetRoutes() *RoutesConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Routes); ok {
		return x.Routes
	}
	return nil
}

func (x *ConstraintProto) GetTable() *TableConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Table); ok {
		return x.Table
	}
	return nil
}

func (x *ConstraintProto) GetAutomaton() *AutomatonConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Automaton); ok {
		return x.Automaton
	}
	return nil
}

func (x *ConstraintProto) GetInverse() *InverseConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Inverse); ok {
		return x.Inverse
	}
	return nil
}

func (x *ConstraintProto) GetReservoir() *ReservoirConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Reservoir); ok {
		return x.Reservoir
	}
	return nil
}

func (x *ConstraintProto) GetInterval() *IntervalConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Interval); ok {
		return x.Interval
	}
	return nil
}

func (x *ConstraintProto) GetNoOverlap() *NoOverlapConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_NoOverlap); ok {
		return x.NoOverlap
	}
	return nil
}

func (x *ConstraintProto) GetNoOverlap_2D() *NoOverlap2DConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_NoOverlap_2D); ok {
		return x.NoOverlap_2D
	}
	return nil
}

func (x *ConstraintProto) GetCumulative() *CumulativeConstraintProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_Cumulative); ok {
		return x.Cumulative
	}
	return nil
}

func (x *ConstraintProto) GetDummyConstraint() *ListOfVariablesProto {
	if x, ok := x.GetConstraint().(*ConstraintProto_DummyConstraint); ok {
		return x.DummyConstraint
	}
	return nil
}

type isConstraintProto_Constraint interface {
	isConstraintProto_Constraint()
}

type ConstraintProto_BoolOr struct {
	// The bool_or constraint forces at least one literal to be true.
	BoolOr *BoolArgumentProto `protobuf:"bytes,3,opt,name=bool_or,json=boolOr,proto3,oneof"`
}

type ConstraintProto_BoolAnd struct {
	// The bool_and constraint forces all of the literals to be true.
	//
	// This is a "redundant" constraint in the sense that this can easily be
	// encoded with many bool_or or at_most_one. It is just more space efficient
	// and handled slightly differently internally.
	BoolAnd *BoolArgumentProto `protobuf:"bytes,4,opt,name=bool_and,json=boolAnd,proto3,oneof"`
}

type ConstraintProto_AtMostOne struct {
	// The at_most_one constraint enforces that no more than one literal is
	// true at the same time.
	//
	// Note that an at most one constraint of length n could be encoded with n
	// bool_and constraint with n-1 term on the right hand side. So in a sense,
	// this constraint contribute directly to the "implication-graph" or the
	// 2-SAT part of the model.
	//
	// This constraint does not support enforcement_literal. Just use a linear
	// constraint if you need to enforce it. You also do not need to use it
	// directly, we will extract it from the model in most situations.
	AtMostOne *BoolArgumentProto `protobuf:"bytes,26,opt,name=at_most_one,json=atMostOne,proto3,oneof"`
}

type ConstraintProto_ExactlyOne struct {
	// The exactly_one constraint force exactly one literal to true and no more.
	//
	// Anytime a bool_or (it could have been called at_least_one) is included
	// into an at_most_one, then the bool_or is actually an exactly one
	// constraint, and the extra literal in the at_most_one can be set to false.
	// So in this sense, this constraint is not really needed. it is just here
	// for a better description of the problem structure and to facilitate some
	// algorithm.
	//
	// This constraint does not support enforcement_literal. Just use a linear
	// constraint if you need to enforce it. You also do not need to use it
	// directly, we will extract it from the model in most situations.
	ExactlyOne *BoolArgumentProto `protobuf:"bytes,29,opt,name=exactly_one,json=exactlyOne,proto3,oneof"`
}

type ConstraintProto_BoolXor struct {
	// The bool_xor constraint forces an odd number of the literals to be true.
	BoolXor *BoolArgumentProto `protobuf:"bytes,5,opt,name=bool_xor,json=boolXor,proto3,oneof"`
}

type ConstraintProto_IntDiv struct {
	// The int_div constraint forces the target to equal exprs[0] / exprs[1].
	// The division is "rounded" towards zero, so we can have for instance
	// (2 = 12 / 5) or (-3 = -10 / 3). If you only want exact integer division,
	// then you should use instead of t = a / b, the int_prod constraint
	// a = b * t.
	//
	// If 0 belongs to the domain of exprs[1], then the model is deemed invalid.
	IntDiv *LinearArgumentProto `protobuf:"bytes,7,opt,name=int_div,json=intDiv,proto3,oneof"`
}

type ConstraintProto_IntMod struct {
	// The int_mod constraint forces the target to equal exprs[0] % exprs[1].
	// The domain of exprs[1] must be strictly positive. The sign of the target
	// is the same as the sign of exprs[0].
	IntMod *LinearArgumentProto `protobuf:"bytes,8,opt,name=int_mod,json=intMod,proto3,oneof"`
}

type ConstraintProto_IntProd struct {
	// The int_prod constraint forces the target to equal the product of all
	// variables. By convention, because we can just remove term equal to one,
	// the empty product forces the target to be one.
	//
	// Note that the solver checks for potential integer overflow. So the
	// product of the maximum absolute value of all the terms (using the initial
	// domain) should fit on an int64. Otherwise the model will be declared
	// invalid.
	IntProd *LinearArgumentProto `protobuf:"bytes,11,opt,name=int_prod,json=intProd,proto3,oneof"`
}

type ConstraintProto_LinMax struct {
	// The lin_max constraint forces the target to equal the maximum of all
	// linear expressions.
	// Note that this can model a minimum simply by negating all expressions.
	LinMax *LinearArgumentProto `protobuf:"bytes,27,opt,name=lin_max,json=linMax,proto3,oneof"`
}

type ConstraintProto_Linear struct {
	// The linear constraint enforces a linear inequality among the variables,
	// such as 0 <= x + 2y <= 10.
	Linear *LinearConstraintProto `protobuf:"bytes,12,opt,name=linear,proto3,oneof"`
}

type ConstraintProto_AllDiff struct {
	// The all_diff constraint forces all variables to take different values.
	AllDiff *AllDifferentConstraintProto `protobuf:"bytes,13,opt,name=all_diff,json=allDiff,proto3,oneof"`
}

type ConstraintProto_Element struct {
	// The element constraint forces the variable with the given index
	// to be equal to the target.
	Element *ElementConstraintProto `protobuf:"bytes,14,opt,name=element,proto3,oneof"`
}

type ConstraintProto_Circuit struct {
	// The circuit constraint takes a graph and forces the arcs present
	// (with arc presence indicated by a literal) to form a unique cycle.
	Circuit *CircuitConstraintProto `protobuf:"bytes,15,opt,name=circuit,proto3,oneof"`
}

type ConstraintProto_Routes struct {
	// The routes constraint implements the vehicle routing problem.
	Routes *RoutesConstraintProto `protobuf:"bytes,23,opt,name=routes,proto3,oneof"`
}

type ConstraintProto_Table struct {
	// The table constraint enforces what values a tuple of variables may
	// take.
	Table *TableConstraintProto `protobuf:"bytes,16,opt,name=table,proto3,oneof"`
}

type ConstraintProto_Automaton struct {
	// The automaton constraint forces a sequence of variables to be accepted
	// by an automaton.
	Automaton *AutomatonConstraintProto `protobuf:"bytes,17,opt,name=automaton,proto3,oneof"`
}

type ConstraintProto_Inverse struct {
	// The inverse constraint forces two arrays to be inverses of each other:
	// the values of one are the indices of the other, and vice versa.
	Inverse *InverseConstraintProto `protobuf:"bytes,18,opt,name=inverse,proto3,oneof"`
}

type ConstraintProto_Reservoir struct {
	// The reservoir constraint forces the sum of a set of active demands
	// to always be between a specified minimum and maximum value during
	// specific times.
	Reservoir *ReservoirConstraintProto `protobuf:"bytes,24,opt,name=reservoir,proto3,oneof"`
}

type ConstraintProto_Interval struct {
	// The interval constraint takes a start, end, and size, and forces
	// start + size == end.
	Interval *IntervalConstraintProto `protobuf:"bytes,19,opt,name=interval,proto3,oneof"`
}

type ConstraintProto_NoOverlap struct {
	// The no_overlap constraint prevents a set of intervals from
	// overlapping; in scheduling, this is called a disjunctive
	// constraint.
	NoOverlap *NoOverlapConstraintProto `protobuf:"bytes,20,opt,name=no_overlap,json=noOverlap,proto3,oneof"`
}

type ConstraintProto_NoOverlap_2D struct {
	// The no_overlap_2d constraint prevents a set of boxes from overlapping.
	NoOverlap_2D *NoOverlap2DConstraintProto `protobuf:"bytes,21,opt,name=no_overlap_2d,json=noOverlap2d,proto3,oneof"`
}

type ConstraintProto_Cumulative struct {
	// The cumulative constraint ensures that for any integer point, the sum
	// of the demands of the intervals containing that point does not exceed
	// the capacity.
	Cumulative *CumulativeConstraintProto `protobuf:"bytes,22,opt,name=cumulative,proto3,oneof"`
}

type ConstraintProto_DummyConstraint struct {
	// This constraint is not meant to be used and will be rejected by the
	// solver. It is meant to mark variable when testing the presolve code.
	DummyConstraint *ListOfVariablesProto `protobuf:"bytes,30,opt,name=dummy_constraint,json=dummyConstraint,proto3,oneof"`
}

func (*ConstraintProto_BoolOr) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolAnd) isConstraintProto_Constraint() {}

func (*ConstraintProto_AtMostOne) isConstraintProto_Constraint() {}

func (*ConstraintProto_ExactlyOne) isConstraintProto_Constraint() {}

func (*ConstraintProto_BoolXor) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntDiv) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntMod) isConstraintProto_Constraint() {}

func (*ConstraintProto_IntProd) isConstraintProto_Constraint() {}

func (*ConstraintProto_LinMax) isConstraintProto_Constraint() {}

func (*ConstraintProto_Linear) isConstraintProto_Constraint() {}

func (*ConstraintProto_AllDiff) isConstraintProto_Constraint() {}

func (*ConstraintProto_Element) isConstraintProto_Constraint() {}

func (*ConstraintProto_Circuit) isConstraintProto_Constraint() {}

func (*ConstraintProto_Routes) isConstraintProto_Constraint() {}

func (*ConstraintProto_Table) isConstraintProto_Constraint() {}

func (*ConstraintProto_Automaton) isConstraintProto_Constraint() {}

func (*ConstraintProto_Inverse) isConstraintProto_Constraint() {}

func (*ConstraintProto_Reservoir) isConstraintProto_Constraint() {}

func (*ConstraintProto_Interval) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap) isConstraintProto_Constraint() {}

func (*ConstraintProto_NoOverlap_2D) isConstraintProto_Constraint() {}

func (*ConstraintProto_Cumulative) isConstraintProto_Constraint() {}

func (*ConstraintProto_DummyConstraint) isConstraintProto_Constraint() {}

// Optimization objective.
type CpObjectiveProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The linear terms of the objective to minimize.
	// For a maximization problem, one can negate all coefficients in the
	// objective and set scaling_factor to -1.
	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []int64 `protobuf:"varint,4,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	// The displayed objective is always:
	//
	//	scaling_factor * (sum(coefficients[i] * objective_vars[i]) + offset).
	//
	// This is needed to have a consistent objective after presolve or when
	// scaling a double problem to express it with integers.
	//
	// Note that if scaling_factor is zero, then it is assumed to be 1, so that by
	// default these fields have no effect.
	Offset        float64 `protobuf:"fixed64,2,opt,name=offset,proto3" json:"offset,omitempty"`
	ScalingFactor float64 `protobuf:"fixed64,3,opt,name=scaling_factor,json=scalingFactor,proto3" json:"scaling_factor,omitempty"`
	// If non-empty, only look for an objective value in the given domain.
	// Note that this does not depend on the offset or scaling factor, it is a
	// domain on the sum of the objective terms only.
	Domain []int64 `protobuf:"varint,5,rep,packed,name=domain,proto3" json:"domain,omitempty"`
	// Internal field. Do not set. When we scale a FloatObjectiveProto to a
	// integer version, we set this to true if the scaling was exact (i.e. all
	// original coeff were integer for instance).
	//
	// TODO(user): Put the error bounds we computed instead?
	ScalingWasExact bool `protobuf:"varint,6,opt,name=scaling_was_exact,json=scalingWasExact,proto3" json:"scaling_was_exact,omitempty"`
	// Internal fields to recover a bound on the original integer objective from
	// the presolved one. Basically, initially the integer objective fit on an
	// int64 and is in [Initial_lb, Initial_ub]. During presolve, we might change
	// the linear expression to have a new domain [Presolved_lb, Presolved_ub]
	// that will also always fit on an int64.
	//
	// The two domain will always be linked with an affine transformation between
	// the two of the form:
	//
	//	old = (new + before_offset) * integer_scaling_factor + after_offset.
	//
	// Note that we use both offsets to always be able to do the computation while
	// staying in the int64 domain. In particular, the after_offset will always
	// be in (-integer_scaling_factor, integer_scaling_factor).
	IntegerBeforeOffset  int64 `protobuf:"varint,7,opt,name=integer_before_offset,json=integerBeforeOffset,proto3" json:"integer_before_offset,omitempty"`
	IntegerAfterOffset   int64 `protobuf:"varint,9,opt,name=integer_after_offset,json=integerAfterOffset,proto3" json:"integer_after_offset,omitempty"`
	IntegerScalingFactor int64 `protobuf:"varint,8,opt,name=integer_scaling_factor,json=integerScalingFactor,proto3" json:"integer_scaling_factor,omitempty"`
}

func (x *CpObjectiveProto) Reset() {
	*x = CpObjectiveProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpObjectiveProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpObjectiveProto) ProtoMessage() {}

func (x *CpObjectiveProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpObjectiveProto.ProtoReflect.Descriptor instead.
func (*CpObjectiveProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{19}
}

func (x *CpObjectiveProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *CpObjectiveProto) GetCoeffs() []int64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *CpObjectiveProto) GetOffset() float64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *CpObjectiveProto) GetScalingFactor() float64 {
	if x != nil {
		return x.ScalingFactor
	}
	return 0
}

func (x *CpObjectiveProto) GetDomain() []int64 {
	if x != nil {
		return x.Domain
	}
	return nil
}

func (x *CpObjectiveProto) GetScalingWasExact() bool {
	if x != nil {
		return x.ScalingWasExact
	}
	return false
}

func (x *CpObjectiveProto) GetIntegerBeforeOffset() int64 {
	if x != nil {
		return x.IntegerBeforeOffset
	}
	return 0
}

func (x *CpObjectiveProto) GetIntegerAfterOffset() int64 {
	if x != nil {
		return x.IntegerAfterOffset
	}
	return 0
}

func (x *CpObjectiveProto) GetIntegerScalingFactor() int64 {
	if x != nil {
		return x.IntegerScalingFactor
	}
	return 0
}

// A linear floating point objective: sum coeffs[i] * vars[i] + offset.
// Note that the variable can only still take integer value.
type FloatObjectiveProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32   `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Coeffs []float64 `protobuf:"fixed64,2,rep,packed,name=coeffs,proto3" json:"coeffs,omitempty"`
	Offset float64   `protobuf:"fixed64,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// The optimization direction. The default is to minimize
	Maximize bool `protobuf:"varint,4,opt,name=maximize,proto3" json:"maximize,omitempty"`
}

func (x *FloatObjectiveProto) Reset() {
	*x = FloatObjectiveProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FloatObjectiveProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FloatObjectiveProto) ProtoMessage() {}

func (x *FloatObjectiveProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FloatObjectiveProto.ProtoReflect.Descriptor instead.
func (*FloatObjectiveProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{20}
}

func (x *FloatObjectiveProto) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *FloatObjectiveProto) GetCoeffs() []float64 {
	if x != nil {
		return x.Coeffs
	}
	return nil
}

func (x *FloatObjectiveProto) GetOffset() float64 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *FloatObjectiveProto) GetMaximize() bool {
	if x != nil {
		return x.Maximize
	}
	return false
}

// Define the strategy to follow when the solver needs to take a new decision.
// Note that this strategy is only defined on a subset of variables.
type DecisionStrategyProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The variables to be considered for the next decision. The order matter and
	// is always used as a tie-breaker after the variable selection strategy
	// criteria defined below.
	Variables []int32 `protobuf:"varint,1,rep,packed,name=variables,proto3" json:"variables,omitempty"`
	// If this is set, then the variables field must be empty.
	// We currently only support affine expression.
	//
	// Note that this is needed so that if a variable has an affine
	// representative, we can properly transform a DecisionStrategyProto through
	// presolve.
	Exprs                     []*LinearExpressionProto                        `protobuf:"bytes,5,rep,name=exprs,proto3" json:"exprs,omitempty"`
	VariableSelectionStrategy DecisionStrategyProto_VariableSelectionStrategy `protobuf:"varint,2,opt,name=variable_selection_strategy,json=variableSelectionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_VariableSelectionStrategy" json:"variable_selection_strategy,omitempty"`
	DomainReductionStrategy   DecisionStrategyProto_DomainReductionStrategy   `protobuf:"varint,3,opt,name=domain_reduction_strategy,json=domainReductionStrategy,proto3,enum=operations_research.sat.DecisionStrategyProto_DomainReductionStrategy" json:"domain_reduction_strategy,omitempty"`
}

func (x *DecisionStrategyProto) Reset() {
	*x = DecisionStrategyProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DecisionStrategyProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DecisionStrategyProto) ProtoMessage() {}

func (x *DecisionStrategyProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DecisionStrategyProto.ProtoReflect.Descriptor instead.
func (*DecisionStrategyProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{21}
}

func (x *DecisionStrategyProto) GetVariables() []int32 {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *DecisionStrategyProto) GetExprs() []*LinearExpressionProto {
	if x != nil {
		return x.Exprs
	}
	return nil
}

func (x *DecisionStrategyProto) GetVariableSelectionStrategy() DecisionStrategyProto_VariableSelectionStrategy {
	if x != nil {
		return x.VariableSelectionStrategy
	}
	return DecisionStrategyProto_CHOOSE_FIRST
}

func (x *DecisionStrategyProto) GetDomainReductionStrategy() DecisionStrategyProto_DomainReductionStrategy {
	if x != nil {
		return x.DomainReductionStrategy
	}
	return DecisionStrategyProto_SELECT_MIN_VALUE
}

// This message encodes a partial (or full) assignment of the variables of a
// CpModelProto. The variable indices should be unique and valid variable
// indices.
type PartialVariableAssignment struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Vars   []int32 `protobuf:"varint,1,rep,packed,name=vars,proto3" json:"vars,omitempty"`
	Values []int64 `protobuf:"varint,2,rep,packed,name=values,proto3" json:"values,omitempty"`
}

func (x *PartialVariableAssignment) Reset() {
	*x = PartialVariableAssignment{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[22]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *PartialVariableAssignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PartialVariableAssignment) ProtoMessage() {}

func (x *PartialVariableAssignment) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[22]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PartialVariableAssignment.ProtoReflect.Descriptor instead.
func (*PartialVariableAssignment) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{22}
}

func (x *PartialVariableAssignment) GetVars() []int32 {
	if x != nil {
		return x.Vars
	}
	return nil
}

func (x *PartialVariableAssignment) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

// A permutation of integers encoded as a list of cycles, hence the "sparse"
// format. The image of an element cycle[i] is cycle[(i + 1) % cycle_length].
type SparsePermutationProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Each cycle is listed one after the other in the support field.
	// The size of each cycle is given (in order) in the cycle_sizes field.
	Support    []int32 `protobuf:"varint,1,rep,packed,name=support,proto3" json:"support,omitempty"`
	CycleSizes []int32 `protobuf:"varint,2,rep,packed,name=cycle_sizes,json=cycleSizes,proto3" json:"cycle_sizes,omitempty"`
}

func (x *SparsePermutationProto) Reset() {
	*x = SparsePermutationProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[23]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SparsePermutationProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SparsePermutationProto) ProtoMessage() {}

func (x *SparsePermutationProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[23]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SparsePermutationProto.ProtoReflect.Descriptor instead.
func (*SparsePermutationProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{23}
}

func (x *SparsePermutationProto) GetSupport() []int32 {
	if x != nil {
		return x.Support
	}
	return nil
}

func (x *SparsePermutationProto) GetCycleSizes() []int32 {
	if x != nil {
		return x.CycleSizes
	}
	return nil
}

// A dense matrix of numbers encoded in a flat way, row by row.
// That is matrix[i][j] = entries[i * num_cols + j];
type DenseMatrixProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	NumRows int32   `protobuf:"varint,1,opt,name=num_rows,json=numRows,proto3" json:"num_rows,omitempty"`
	NumCols int32   `protobuf:"varint,2,opt,name=num_cols,json=numCols,proto3" json:"num_cols,omitempty"`
	Entries []int32 `protobuf:"varint,3,rep,packed,name=entries,proto3" json:"entries,omitempty"`
}

func (x *DenseMatrixProto) Reset() {
	*x = DenseMatrixProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[24]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *DenseMatrixProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DenseMatrixProto) ProtoMessage() {}

func (x *DenseMatrixProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[24]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DenseMatrixProto.ProtoReflect.Descriptor instead.
func (*DenseMatrixProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{24}
}

func (x *DenseMatrixProto) GetNumRows() int32 {
	if x != nil {
		return x.NumRows
	}
	return 0
}

func (x *DenseMatrixProto) GetNumCols() int32 {
	if x != nil {
		return x.NumCols
	}
	return 0
}

func (x *DenseMatrixProto) GetEntries() []int32 {
	if x != nil {
		return x.Entries
	}
	return nil
}

// EXPERIMENTAL. For now, this is meant to be used by the solver and not filled
// by clients.
//
// Hold symmetry information about the set of feasible solutions. If we permute
// the variable values of any feasible solution using one of the permutation
// described here, we should always get another feasible solution.
//
// We usually also enforce that the objective of the new solution is the same.
//
// The group of permutations encoded here is usually computed from the encoding
// of the model, so it is not meant to be a complete representation of the
// feasible solution symmetries, just a valid subgroup.
type SymmetryProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A list of variable indices permutations that leave the feasible space of
	// solution invariant. Usually, we only encode a set of generators of the
	// group.
	Permutations []*SparsePermutationProto `protobuf:"bytes,1,rep,name=permutations,proto3" json:"permutations,omitempty"`
	// An orbitope is a special symmetry structure of the solution space. If the
	// variable indices are arranged in a matrix (with no duplicates), then any
	// permutation of the columns will be a valid permutation of the feasible
	// space.
	//
	// This arise quite often. The typical example is a graph coloring problem
	// where for each node i, you have j booleans to indicate its color. If the
	// variables color_of_i_is_j are arranged in a matrix[i][j], then any columns
	// permutations leave the problem invariant.
	Orbitopes []*DenseMatrixProto `protobuf:"bytes,2,rep,name=orbitopes,proto3" json:"orbitopes,omitempty"`
}

func (x *SymmetryProto) Reset() {
	*x = SymmetryProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[25]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *SymmetryProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SymmetryProto) ProtoMessage() {}

func (x *SymmetryProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[25]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SymmetryProto.ProtoReflect.Descriptor instead.
func (*SymmetryProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{25}
}

func (x *SymmetryProto) GetPermutations() []*SparsePermutationProto {
	if x != nil {
		return x.Permutations
	}
	return nil
}

func (x *SymmetryProto) GetOrbitopes() []*DenseMatrixProto {
	if x != nil {
		return x.Orbitopes
	}
	return nil
}

// A constraint programming problem.
type CpModelProto struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// For debug/logging only. Can be empty.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The associated Protos should be referred by their index in these fields.
	Variables   []*IntegerVariableProto `protobuf:"bytes,2,rep,name=variables,proto3" json:"variables,omitempty"`
	Constraints []*ConstraintProto      `protobuf:"bytes,3,rep,name=constraints,proto3" json:"constraints,omitempty"`
	// The objective to minimize. Can be empty for pure decision problems.
	Objective *CpObjectiveProto `protobuf:"bytes,4,opt,name=objective,proto3" json:"objective,omitempty"`
	// Advanced usage.
	// It is invalid to have both an objective and a floating point objective.
	//
	// The objective of the model, in floating point format. The solver will
	// automatically scale this to integer during expansion and thus convert it to
	// a normal CpObjectiveProto. See the mip* parameters to control how this is
	// scaled. In most situation the precision will be good enough, but you can
	// see the logs to see what are the precision guaranteed when this is
	// converted to a fixed point representation.
	//
	// Note that even if the precision is bad, the returned objective_value and
	// best_objective_bound will be computed correctly. So at the end of the solve
	// you can check the gap if you only want precise optimal.
	FloatingPointObjective *FloatObjectiveProto `protobuf:"bytes,9,opt,name=floating_point_objective,json=floatingPointObjective,proto3" json:"floating_point_objective,omitempty"`
	// Defines the strategy that the solver should follow when the
	// search_branching parameter is set to FIXED_SEARCH. Note that this strategy
	// is also used as a heuristic when we are not in fixed search.
	//
	// Advanced Usage: if not all variables appears and the parameter
	// "instantiate_all_variables" is set to false, then the solver will not try
	// to instantiate the variables that do not appear. Thus, at the end of the
	// search, not all variables may be fixed. Currently, we will set them to
	// their lower bound in the solution.
	SearchStrategy []*DecisionStrategyProto `protobuf:"bytes,5,rep,name=search_strategy,json=searchStrategy,proto3" json:"search_strategy,omitempty"`
	// Solution hint.
	//
	// If a feasible or almost-feasible solution to the problem is already known,
	// it may be helpful to pass it to the solver so that it can be used. The
	// solver will try to use this information to create its initial feasible
	// solution.
	//
	// Note that it may not always be faster to give a hint like this to the
	// solver. There is also no guarantee that the solver will use this hint or
	// try to return a solution "close" to this assignment in case of multiple
	// optimal solutions.
	SolutionHint *PartialVariableAssignment `protobuf:"bytes,6,opt,name=solution_hint,json=solutionHint,proto3" json:"solution_hint,omitempty"`
	// A list of literals. The model will be solved assuming all these literals
	// are true. Compared to just fixing the domain of these literals, using this
	// mechanism is slower but allows in case the model is INFEASIBLE to get a
	// potentially small subset of them that can be used to explain the
	// infeasibility.
	//
	// Think (IIS), except when you are only concerned by the provided
	// assumptions. This is powerful as it allows to group a set of logically
	// related constraint under only one enforcement literal which can potentially
	// give you a good and interpretable explanation for infeasiblity.
	//
	// Such infeasibility explanation will be available in the
	// sufficient_assumptions_for_infeasibility response field.
	Assumptions []int32 `protobuf:"varint,7,rep,packed,name=assumptions,proto3" json:"assumptions,omitempty"`
	// For now, this is not meant to be filled by a client writing a model, but
	// by our preprocessing step.
	//
	// Information about the symmetries of the feasible solution space.
	// These usually leaves the objective invariant.
	Symmetry *SymmetryProto `protobuf:"bytes,8,opt,name=symmetry,proto3" json:"symmetry,omitempty"`
}

func (x *CpModelProto) Reset() {
	*x = CpModelProto{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[26]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpModelProto) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpModelProto) ProtoMessage() {}

func (x *CpModelProto) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[26]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpModelProto.ProtoReflect.Descriptor instead.
func (*CpModelProto) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{26}
}

func (x *CpModelProto) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CpModelProto) GetVariables() []*IntegerVariableProto {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *CpModelProto) GetConstraints() []*ConstraintProto {
	if x != nil {
		return x.Constraints
	}
	return nil
}

func (x *CpModelProto) GetObjective() *CpObjectiveProto {
	if x != nil {
		return x.Objective
	}
	return nil
}

func (x *CpModelProto) GetFloatingPointObjective() *FloatObjectiveProto {
	if x != nil {
		return x.FloatingPointObjective
	}
	return nil
}

func (x *CpModelProto) GetSearchStrategy() []*DecisionStrategyProto {
	if x != nil {
		return x.SearchStrategy
	}
	return nil
}

func (x *CpModelProto) GetSolutionHint() *PartialVariableAssignment {
	if x != nil {
		return x.SolutionHint
	}
	return nil
}

func (x *CpModelProto) GetAssumptions() []int32 {
	if x != nil {
		return x.Assumptions
	}
	return nil
}

func (x *CpModelProto) GetSymmetry() *SymmetryProto {
	if x != nil {
		return x.Symmetry
	}
	return nil
}

// Just a message used to store dense solution.
// This is used by the additional_solutions field.
type CpSolverSolution struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	Values []int64 `protobuf:"varint,1,rep,packed,name=values,proto3" json:"values,omitempty"`
}

func (x *CpSolverSolution) Reset() {
	*x = CpSolverSolution{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[27]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpSolverSolution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpSolverSolution) ProtoMessage() {}

func (x *CpSolverSolution) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[27]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpSolverSolution.ProtoReflect.Descriptor instead.
func (*CpSolverSolution) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{27}
}

func (x *CpSolverSolution) GetValues() []int64 {
	if x != nil {
		return x.Values
	}
	return nil
}

// The response returned by a solver trying to solve a CpModelProto.
//
// Next id: 31
type CpSolverResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The status of the solve.
	Status CpSolverStatus `protobuf:"varint,1,opt,name=status,proto3,enum=operations_research.sat.CpSolverStatus" json:"status,omitempty"`
	// A feasible solution to the given problem. Depending on the returned status
	// it may be optimal or just feasible. This is in one-to-one correspondence
	// with a CpModelProto::variables repeated field and list the values of all
	// the variables.
	Solution []int64 `protobuf:"varint,2,rep,packed,name=solution,proto3" json:"solution,omitempty"`
	// Only make sense for an optimization problem. The objective value of the
	// returned solution if it is non-empty. If there is no solution, then for a
	// minimization problem, this will be an upper-bound of the objective of any
	// feasible solution, and a lower-bound for a maximization problem.
	ObjectiveValue float64 `protobuf:"fixed64,3,opt,name=objective_value,json=objectiveValue,proto3" json:"objective_value,omitempty"`
	// Only make sense for an optimization problem. A proven lower-bound on the
	// objective for a minimization problem, or a proven upper-bound for a
	// maximization problem.
	BestObjectiveBound float64 `protobuf:"fixed64,4,opt,name=best_objective_bound,json=bestObjectiveBound,proto3" json:"best_objective_bound,omitempty"`
	// If the parameter fill_additional_solutions_in_response is set, then we
	// copy all the solutions from our internal solution pool here.
	//
	// Note that the one returned in the solution field will likely appear here
	// too. Do not rely on the solutions order as it depends on our internal
	// representation (after postsolve).
	AdditionalSolutions []*CpSolverSolution `protobuf:"bytes,27,rep,name=additional_solutions,json=additionalSolutions,proto3" json:"additional_solutions,omitempty"`
	// Advanced usage.
	//
	// If the option fill_tightened_domains_in_response is set, then this field
	// will be a copy of the CpModelProto.variables where each domain has been
	// reduced using the information the solver was able to derive. Note that this
	// is only filled with the info derived during a normal search and we do not
	// have any dedicated algorithm to improve it.
	//
	// If the problem is a feasibility problem, then these bounds will be valid
	// for any feasible solution. If the problem is an optimization problem, then
	// these bounds will only be valid for any OPTIMAL solutions, it can exclude
	// sub-optimal feasible ones.
	TightenedVariables []*IntegerVariableProto `protobuf:"bytes,21,rep,name=tightened_variables,json=tightenedVariables,proto3" json:"tightened_variables,omitempty"`
	// A subset of the model "assumptions" field. This will only be filled if the
	// status is INFEASIBLE. This subset of assumption will be enough to still get
	// an infeasible problem.
	//
	// This is related to what is called the irreducible inconsistent subsystem or
	// IIS. Except one is only concerned by the provided assumptions. There is
	// also no guarantee that we return an irreducible (aka minimal subset).
	// However, this is based on SAT explanation and there is a good chance it is
	// not too large.
	//
	// If you really want a minimal subset, a possible way to get one is by
	// changing your model to minimize the number of assumptions at false, but
	// this is likely an harder problem to solve.
	//
	// Important: Currently, this is minimized only in single-thread and if the
	// problem is not an optimization problem, otherwise, it will always include
	// all the assumptions.
	//
	// TODO(user): Allows for returning multiple core at once.
	SufficientAssumptionsForInfeasibility []int32 `protobuf:"varint,23,rep,packed,name=sufficient_assumptions_for_infeasibility,json=sufficientAssumptionsForInfeasibility,proto3" json:"sufficient_assumptions_for_infeasibility,omitempty"`
	// Contains the integer objective optimized internally. This is only filled if
	// the problem had a floating point objective, and on the final response, not
	// the ones given to callbacks.
	IntegerObjective *CpObjectiveProto `protobuf:"bytes,28,opt,name=integer_objective,json=integerObjective,proto3" json:"integer_objective,omitempty"`
	// Advanced usage.
	//
	// A lower bound on the inner integer expression of the objective. This is
	// either a bound on the expression in the returned integer_objective or on
	// the integer expression of the original objective if the problem already has
	// an integer objective.
	InnerObjectiveLowerBound int64 `protobuf:"varint,29,opt,name=inner_objective_lower_bound,json=innerObjectiveLowerBound,proto3" json:"inner_objective_lower_bound,omitempty"`
	// Some statistics about the solve.
	//
	// Important: in multithread, this correspond the statistics of the first
	// subsolver. Which is usually the one with the user defined parameters. Or
	// the default-search if none are specified.
	NumIntegers            int64 `protobuf:"varint,30,opt,name=num_integers,json=numIntegers,proto3" json:"num_integers,omitempty"`
	NumBooleans            int64 `protobuf:"varint,10,opt,name=num_booleans,json=numBooleans,proto3" json:"num_booleans,omitempty"`
	NumConflicts           int64 `protobuf:"varint,11,opt,name=num_conflicts,json=numConflicts,proto3" json:"num_conflicts,omitempty"`
	NumBranches            int64 `protobuf:"varint,12,opt,name=num_branches,json=numBranches,proto3" json:"num_branches,omitempty"`
	NumBinaryPropagations  int64 `protobuf:"varint,13,opt,name=num_binary_propagations,json=numBinaryPropagations,proto3" json:"num_binary_propagations,omitempty"`
	NumIntegerPropagations int64 `protobuf:"varint,14,opt,name=num_integer_propagations,json=numIntegerPropagations,proto3" json:"num_integer_propagations,omitempty"`
	NumRestarts            int64 `protobuf:"varint,24,opt,name=num_restarts,json=numRestarts,proto3" json:"num_restarts,omitempty"`
	NumLpIterations        int64 `protobuf:"varint,25,opt,name=num_lp_iterations,json=numLpIterations,proto3" json:"num_lp_iterations,omitempty"`
	// The time counted from the beginning of the Solve() call.
	WallTime          float64 `protobuf:"fixed64,15,opt,name=wall_time,json=wallTime,proto3" json:"wall_time,omitempty"`
	UserTime          float64 `protobuf:"fixed64,16,opt,name=user_time,json=userTime,proto3" json:"user_time,omitempty"`
	DeterministicTime float64 `protobuf:"fixed64,17,opt,name=deterministic_time,json=deterministicTime,proto3" json:"deterministic_time,omitempty"`
	// The integral of log(1 + absolute_objective_gap) over time.
	GapIntegral float64 `protobuf:"fixed64,22,opt,name=gap_integral,json=gapIntegral,proto3" json:"gap_integral,omitempty"`
	// Additional information about how the solution was found. It also stores
	// model or parameters errors that caused the model to be invalid.
	SolutionInfo string `protobuf:"bytes,20,opt,name=solution_info,json=solutionInfo,proto3" json:"solution_info,omitempty"`
	// The solve log will be filled if the parameter log_to_response is set to
	// true.
	SolveLog string `protobuf:"bytes,26,opt,name=solve_log,json=solveLog,proto3" json:"solve_log,omitempty"`
}

func (x *CpSolverResponse) Reset() {
	*x = CpSolverResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_cp_model_proto_msgTypes[28]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CpSolverResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CpSolverResponse) ProtoMessage() {}

func (x *CpSolverResponse) ProtoReflect() protoreflect.Message {
	mi := &file_cp_model_proto_msgTypes[28]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CpSolverResponse.ProtoReflect.Descriptor instead.
func (*CpSolverResponse) Descriptor() ([]byte, []int) {
	return file_cp_model_proto_rawDescGZIP(), []int{28}
}

func (x *CpSolverResponse) GetStatus() CpSolverStatus {
	if x != nil {
		return x.Status
	}
	return CpSolverStatus_UNKNOWN
}

func (x *CpSolverResponse) GetSolution() []int64 {
	if x != nil {
		return x.Solution
	}
	return nil
}

func (x *CpSolverResponse) GetObjectiveValue() float64 {
	if x != nil {
		return x.ObjectiveValue
	}
	return 0
}

func (x *CpSolverResponse) GetBestObjectiveBound() float64 {
	if x != nil {
		return x.BestObjectiveBound
	}
	return 0
}

func (x *CpSolverResponse) GetAdditionalSolutions() []*CpSolverSolution {
	if x != nil {
		return x.AdditionalSolutions
	}
	return nil
}

func (x *CpSolverResponse) GetTightenedVariables() []*IntegerVariableProto {
	if x != nil {
		return x.TightenedVariables
	}
	return nil
}

func (x *CpSolverResponse) GetSufficientAssumptionsForInfeasibility() []int32 {
	if x != nil {
		return x.SufficientAssumptionsForInfeasibility
	}
	return nil
}

func (x *CpSolverResponse) GetIntegerObjective() *CpObjectiveProto {
	if x != nil {
		return x.IntegerObjective
	}
	return nil
}

func (x *CpSolverResponse) GetInnerObjectiveLowerBound() int64 {
	if x != nil {
		return x.InnerObjectiveLowerBound
	}
	return 0
}

func (x *CpSolverResponse) GetNumIntegers() int64 {
	if x != nil {
		return x.NumIntegers
	}
	return 0
}

func (x *CpSolverResponse) GetNumBooleans() int64 {
	if x != nil {
		return x.NumBooleans
	}
	return 0
}

func (x *CpSolverResponse) GetNumConflicts() int64 {
	if x != nil {
		return x.NumConflicts
	}
	return 0
}

func (x *CpSolverResponse) GetNumBranches() int64 {
	if x != nil {
		return x.NumBranches
	}
	return 0
}

func (x *CpSolverResponse) GetNumBinaryPropagations() int64 {
	if x != nil {
		return x.NumBinaryPropagations
	}
	return 0
}

func (x *CpSolverResponse) GetNumIntegerPropagations() int64 {
	if x != nil {
		return x.NumIntegerPropagations
	}
	return 0
}

func (x *CpSolverResponse) GetNumRestarts() int64 {
	if x != nil {
		return x.NumRestarts
	}
	return 0
}

func (x *CpSolverResponse) GetNumLpIterations() int64 {
	if x != nil {
		return x.NumLpIterations
	}
	return 0
}

func (x *CpSolverResponse) GetWallTime() float64 {
	if x != nil {
		return x.WallTime
	}
	return 0
}

func (x *CpSolverResponse) GetUserTime() float64 {
	if x != nil {
		return x.UserTime
	}
	return 0
}

func (x *CpSolverResponse) GetDeterministicTime() float64 {
	if x != nil {
		return x.DeterministicTime
	}
	return 0
}

func (x *CpSolverResponse) GetGapIntegral() float64 {
	if x != nil {
		return x.GapIntegral
	}
	return 0
}

func (x *CpSolverResponse) GetSolutionInfo() string {
	if x != nil {
		return x.SolutionInfo
	}
	return ""
}

func (x *CpSolverResponse) GetSolveLog() string {
	if x != nil {
		return x.SolveLog
	}
	return ""
}

var File_cp_model_proto protoreflect.FileDescriptor

var file_cp_model_proto_rawDesc = []byte{
	0x0a, 0x0e, 0x63, 0x70, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x17, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x22, 0x42, 0x0a, 0x14, 0x49, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
	0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0x2f, 0x0a,
	0x11, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x22, 0x5b,
	0x0a, 0x15, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63,
	0x6f, 0x65, 0x66, 0x66, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x63, 0x6f, 0x65,
	0x66, 0x66, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x22, 0xa3, 0x01, 0x0a, 0x13,
	0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x46, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69,
	0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x44, 0x0a, 0x05, 0x65,
	0x78, 0x70, 0x72, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x65, 0x78, 0x70, 0x72,
	0x73, 0x22, 0x63, 0x0a, 0x1b, 0x41, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66, 0x65, 0x72, 0x65, 0x6e,
	0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x44, 0x0a, 0x05, 0x65, 0x78, 0x70, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72,
	0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52,
	0x05, 0x65, 0x78, 0x70, 0x72, 0x73, 0x22, 0x5b, 0x0a, 0x15, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x03, 0x52, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x64,
	0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x18, 0x03, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x64, 0x6f, 0x6d,
	0x61, 0x69, 0x6e, 0x22, 0x5a, 0x0a, 0x16, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x43, 0x6f,
	0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a,
	0x05, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x05, 0x69, 0x6e,
	0x64, 0x65, 0x78, 0x12, 0x16, 0x0a, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18, 0x02, 0x20,
	0x01, 0x28, 0x05, 0x52, 0x06, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x22,
	0xe5, 0x01, 0x0a, 0x17, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x43, 0x6f, 0x6e, 0x73,
	0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x44, 0x0a, 0x05, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x73, 0x74, 0x61, 0x72,
	0x74, 0x12, 0x40, 0x0a, 0x03, 0x65, 0x6e, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x03,
	0x65, 0x6e, 0x64, 0x12, 0x42, 0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x52, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x22, 0x38, 0x0a, 0x18, 0x4e, 0x6f, 0x4f, 0x76, 0x65,
	0x72, 0x6c, 0x61, 0x70, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73,
	0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x73, 0x22, 0x5e, 0x0a, 0x1a, 0x4e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x32, 0x44,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x1f, 0x0a, 0x0b, 0x78, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x78, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73,
	0x12, 0x1f, 0x0a, 0x0b, 0x79, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x79, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x73, 0x22, 0xcf, 0x01, 0x0a, 0x19, 0x43, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x4a, 0x0a, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65,
	0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x52, 0x08, 0x63, 0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x12, 0x1c, 0x0a, 0x09, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09,
	0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x48, 0x0a, 0x07, 0x64, 0x65, 0x6d,
	0x61, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65,
	0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x07, 0x64, 0x65, 0x6d, 0x61,
	0x6e, 0x64, 0x73, 0x22, 0xa7, 0x02, 0x0a, 0x18, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69,
	0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x12, 0x1b, 0x0a, 0x09, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x01, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x08, 0x6d, 0x69, 0x6e, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x1b, 0x0a,
	0x09, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x08, 0x6d, 0x61, 0x78, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x12, 0x4d, 0x0a, 0x0a, 0x74, 0x69,
	0x6d, 0x65, 0x5f, 0x65, 0x78, 0x70, 0x72, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45,
	0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x09,
	0x74, 0x69, 0x6d, 0x65, 0x45, 0x78, 0x70, 0x72, 0x73, 0x12, 0x53, 0x0a, 0x0d, 0x6c, 0x65, 0x76,
	0x65, 0x6c, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61,
	0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x52, 0x0c, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x12, 0x27,
	0x0a, 0x0f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0e, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x4c,
	0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x4a, 0x04, 0x08, 0x04, 0x10, 0x05, 0x22, 0x60, 0x0a,
	0x16, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x14, 0x0a,
	0x05, 0x68, 0x65, 0x61, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x68, 0x65,
	0x61, 0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x18,
	0x05, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x73, 0x22,
	0x95, 0x01, 0x0a, 0x15, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x69,
	0x6c, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12,
	0x14, 0x0a, 0x05, 0x68, 0x65, 0x61, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x05,
	0x68, 0x65, 0x61, 0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c,
	0x73, 0x12, 0x18, 0x0a, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x03,
	0x28, 0x05, 0x52, 0x07, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x63,
	0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x63,
	0x61, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x22, 0x5c, 0x0a, 0x14, 0x54, 0x61, 0x62, 0x6c, 0x65,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02, 0x20,
	0x03, 0x28, 0x03, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x18, 0x0a, 0x07, 0x6e,
	0x65, 0x67, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x07, 0x6e, 0x65,
	0x67, 0x61, 0x74, 0x65, 0x64, 0x22, 0x50, 0x0a, 0x16, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x19, 0x0a, 0x08, 0x66, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28,
	0x05, 0x52, 0x07, 0x66, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x12, 0x1b, 0x0a, 0x09, 0x66, 0x5f,
	0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x08, 0x66,
	0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x22, 0xf5, 0x01, 0x0a, 0x18, 0x41, 0x75, 0x74, 0x6f,
	0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e, 0x67,
	0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0d, 0x73, 0x74,
	0x61, 0x72, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x66,
	0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
	0x03, 0x52, 0x0b, 0x66, 0x69, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x12, 0x27,
	0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x61, 0x69,
	0x6c, 0x18, 0x04, 0x20, 0x03, 0x28, 0x03, 0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x54, 0x61, 0x69, 0x6c, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x72, 0x61, 0x6e, 0x73,
	0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x18, 0x05, 0x20, 0x03, 0x28, 0x03,
	0x52, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x65, 0x61, 0x64,
	0x12, 0x29, 0x0a, 0x10, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6c,
	0x61, 0x62, 0x65, 0x6c, 0x18, 0x06, 0x20, 0x03, 0x28, 0x03, 0x52, 0x0f, 0x74, 0x72, 0x61, 0x6e,
	0x73, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x22,
	0x2a, 0x0a, 0x14, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x66, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c,
	0x65, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18,
	0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x22, 0xec, 0x0e, 0x0a, 0x0f,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
	0x61, 0x6d, 0x65, 0x12, 0x2f, 0x0a, 0x13, 0x65, 0x6e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65,
	0x6e, 0x74, 0x5f, 0x6c, 0x69, 0x74, 0x65, 0x72, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05,
	0x52, 0x12, 0x65, 0x6e, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x74,
	0x65, 0x72, 0x61, 0x6c, 0x12, 0x45, 0x0a, 0x07, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x6f, 0x72, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e,
	0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x48, 0x00, 0x52, 0x06, 0x62, 0x6f, 0x6f, 0x6c, 0x4f, 0x72, 0x12, 0x47, 0x0a, 0x08, 0x62,
	0x6f, 0x6f, 0x6c, 0x5f, 0x61, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75,
	0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07, 0x62, 0x6f, 0x6f,
	0x6c, 0x41, 0x6e, 0x64, 0x12, 0x4c, 0x0a, 0x0b, 0x61, 0x74, 0x5f, 0x6d, 0x6f, 0x73, 0x74, 0x5f,
	0x6f, 0x6e, 0x65, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x09, 0x61, 0x74, 0x4d, 0x6f, 0x73, 0x74, 0x4f,
	0x6e, 0x65, 0x12, 0x4d, 0x0a, 0x0b, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6c, 0x79, 0x5f, 0x6f, 0x6e,
	0x65, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61,
	0x74, 0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x0a, 0x65, 0x78, 0x61, 0x63, 0x74, 0x6c, 0x79, 0x4f, 0x6e,
	0x65, 0x12, 0x47, 0x0a, 0x08, 0x62, 0x6f, 0x6f, 0x6c, 0x5f, 0x78, 0x6f, 0x72, 0x18, 0x05, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x42, 0x6f,
	0x6f, 0x6c, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
	0x00, 0x52, 0x07, 0x62, 0x6f, 0x6f, 0x6c, 0x58, 0x6f, 0x72, 0x12, 0x47, 0x0a, 0x07, 0x69, 0x6e,
	0x74, 0x5f, 0x64, 0x69, 0x76, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75,
	0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x69, 0x6e, 0x74,
	0x44, 0x69, 0x76, 0x12, 0x47, 0x0a, 0x07, 0x69, 0x6e, 0x74, 0x5f, 0x6d, 0x6f, 0x64, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c,
	0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x69, 0x6e, 0x74, 0x4d, 0x6f, 0x64, 0x12, 0x49, 0x0a, 0x08,
	0x69, 0x6e, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41,
	0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x64, 0x12, 0x47, 0x0a, 0x07, 0x6c, 0x69, 0x6e, 0x5f, 0x6d,
	0x61, 0x78, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x41, 0x72, 0x67, 0x75, 0x6d, 0x65, 0x6e,
	0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x6c, 0x69, 0x6e, 0x4d, 0x61, 0x78,
	0x12, 0x48, 0x0a, 0x06, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61,
	0x72, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x48, 0x00, 0x52, 0x06, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x12, 0x51, 0x0a, 0x08, 0x61, 0x6c,
	0x6c, 0x5f, 0x64, 0x69, 0x66, 0x66, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x41, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66, 0x65, 0x72,
	0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x07, 0x61, 0x6c, 0x6c, 0x44, 0x69, 0x66, 0x66, 0x12, 0x4b, 0x0a,
	0x07, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x45, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
	0x00, 0x52, 0x07, 0x65, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x12, 0x4b, 0x0a, 0x07, 0x63, 0x69,
	0x72, 0x63, 0x75, 0x69, 0x74, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x43, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x07,
	0x63, 0x69, 0x72, 0x63, 0x75, 0x69, 0x74, 0x12, 0x48, 0x0a, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65,
	0x73, 0x18, 0x17, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61,
	0x74, 0x2e, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x73, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69,
	0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x06, 0x72, 0x6f, 0x75, 0x74, 0x65,
	0x73, 0x12, 0x45, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x54, 0x61, 0x62, 0x6c, 0x65,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
	0x00, 0x52, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x51, 0x0a, 0x09, 0x61, 0x75, 0x74, 0x6f,
	0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x41, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00,
	0x52, 0x09, 0x61, 0x75, 0x74, 0x6f, 0x6d, 0x61, 0x74, 0x6f, 0x6e, 0x12, 0x4b, 0x0a, 0x07, 0x69,
	0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x43, 0x6f,
	0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52,
	0x07, 0x69, 0x6e, 0x76, 0x65, 0x72, 0x73, 0x65, 0x12, 0x51, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x65,
	0x72, 0x76, 0x6f, 0x69, 0x72, 0x18, 0x18, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x6f, 0x70,
	0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63,
	0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69, 0x72, 0x43,
	0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00,
	0x52, 0x09, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x6f, 0x69, 0x72, 0x12, 0x4e, 0x0a, 0x08, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x30, 0x2e,
	0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61,
	0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48,
	0x00, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x52, 0x0a, 0x0a, 0x6e,
	0x6f, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x31, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4e, 0x6f, 0x4f, 0x76, 0x65, 0x72,
	0x6c, 0x61, 0x70, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x09, 0x6e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x12,
	0x59, 0x0a, 0x0d, 0x6e, 0x6f, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x5f, 0x32, 0x64,
	0x18, 0x15, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74,
	0x2e, 0x4e, 0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x32, 0x44, 0x43, 0x6f, 0x6e, 0x73,
	0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x0b, 0x6e,
	0x6f, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x70, 0x32, 0x64, 0x12, 0x54, 0x0a, 0x0a, 0x63, 0x75,
	0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74,
	0x69, 0x76, 0x65, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f,
	0x74, 0x6f, 0x48, 0x00, 0x52, 0x0a, 0x63, 0x75, 0x6d, 0x75, 0x6c, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x12, 0x5a, 0x0a, 0x10, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x5f, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x2e, 0x73, 0x61, 0x74, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x4f, 0x66, 0x56, 0x61, 0x72, 0x69, 0x61,
	0x62, 0x6c, 0x65, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x48, 0x00, 0x52, 0x0f, 0x64, 0x75, 0x6d,
	0x6d, 0x79, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x42, 0x0c, 0x0a, 0x0a,
	0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x22, 0xdd, 0x02, 0x0a, 0x10, 0x43,
	0x70, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12,
	0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x04, 0x76,
	0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x03, 0x52, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x6f, 0x66, 0x66,
	0x73, 0x65, 0x74, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66,
	0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0d, 0x73, 0x63, 0x61,
	0x6c, 0x69, 0x6e, 0x67, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x16, 0x0a, 0x06, 0x64, 0x6f,
	0x6d, 0x61, 0x69, 0x6e, 0x18, 0x05, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x64, 0x6f, 0x6d, 0x61,
	0x69, 0x6e, 0x12, 0x2a, 0x0a, 0x11, 0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x77, 0x61,
	0x73, 0x5f, 0x65, 0x78, 0x61, 0x63, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0f, 0x73,
	0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x57, 0x61, 0x73, 0x45, 0x78, 0x61, 0x63, 0x74, 0x12, 0x32,
	0x0a, 0x15, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65,
	0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x03, 0x52, 0x13, 0x69,
	0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x42, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x4f, 0x66, 0x66, 0x73,
	0x65, 0x74, 0x12, 0x30, 0x0a, 0x14, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f, 0x61, 0x66,
	0x74, 0x65, 0x72, 0x5f, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x12, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x41, 0x66, 0x74, 0x65, 0x72, 0x4f, 0x66,
	0x66, 0x73, 0x65, 0x74, 0x12, 0x34, 0x0a, 0x16, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f,
	0x73, 0x63, 0x61, 0x6c, 0x69, 0x6e, 0x67, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x18, 0x08,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x14, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x53, 0x63, 0x61,
	0x6c, 0x69, 0x6e, 0x67, 0x46, 0x61, 0x63, 0x74, 0x6f, 0x72, 0x22, 0x75, 0x0a, 0x13, 0x46, 0x6c,
	0x6f, 0x61, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52,
	0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x18,
	0x02, 0x20, 0x03, 0x28, 0x01, 0x52, 0x06, 0x63, 0x6f, 0x65, 0x66, 0x66, 0x73, 0x12, 0x16, 0x0a,
	0x06, 0x6f, 0x66, 0x66, 0x73, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x06, 0x6f,
	0x66, 0x66, 0x73, 0x65, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x69, 0x7a,
	0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x08, 0x6d, 0x61, 0x78, 0x69, 0x6d, 0x69, 0x7a,
	0x65, 0x22, 0xb1, 0x05, 0x0a, 0x15, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x1c, 0x0a, 0x09, 0x76,
	0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x09,
	0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x44, 0x0a, 0x05, 0x65, 0x78, 0x70,
	0x72, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x4c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x45, 0x78, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x05, 0x65, 0x78, 0x70, 0x72, 0x73, 0x12,
	0x88, 0x01, 0x0a, 0x1b, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x65, 0x6c,
	0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x48, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e,
	0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79,
	0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x65,
	0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52,
	0x19, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69,
	0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x82, 0x01, 0x0a, 0x19, 0x64,
	0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x5f, 0x72, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
	0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x46,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69, 0x6f,
	0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x44,
	0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x52, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74,
	0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x52, 0x17, 0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x52, 0x65,
	0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x22,
	0x94, 0x01, 0x0a, 0x19, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x65, 0x6c, 0x65,
	0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12, 0x10, 0x0a,
	0x0c, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x46, 0x49, 0x52, 0x53, 0x54, 0x10, 0x00, 0x12,
	0x15, 0x0a, 0x11, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x4c, 0x4f, 0x57, 0x45, 0x53, 0x54,
	0x5f, 0x4d, 0x49, 0x4e, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45,
	0x5f, 0x48, 0x49, 0x47, 0x48, 0x45, 0x53, 0x54, 0x5f, 0x4d, 0x41, 0x58, 0x10, 0x02, 0x12, 0x1a,
	0x0a, 0x16, 0x43, 0x48, 0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x4d, 0x49, 0x4e, 0x5f, 0x44, 0x4f, 0x4d,
	0x41, 0x49, 0x4e, 0x5f, 0x53, 0x49, 0x5a, 0x45, 0x10, 0x03, 0x12, 0x1a, 0x0a, 0x16, 0x43, 0x48,
	0x4f, 0x4f, 0x53, 0x45, 0x5f, 0x4d, 0x41, 0x58, 0x5f, 0x44, 0x4f, 0x4d, 0x41, 0x49, 0x4e, 0x5f,
	0x53, 0x49, 0x5a, 0x45, 0x10, 0x04, 0x22, 0x8c, 0x01, 0x0a, 0x17, 0x44, 0x6f, 0x6d, 0x61, 0x69,
	0x6e, 0x52, 0x65, 0x64, 0x75, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65,
	0x67, 0x79, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x4d, 0x49, 0x4e,
	0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x53, 0x45, 0x4c, 0x45,
	0x43, 0x54, 0x5f, 0x4d, 0x41, 0x58, 0x5f, 0x56, 0x41, 0x4c, 0x55, 0x45, 0x10, 0x01, 0x12, 0x15,
	0x0a, 0x11, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x4c, 0x4f, 0x57, 0x45, 0x52, 0x5f, 0x48,
	0x41, 0x4c, 0x46, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f,
	0x55, 0x50, 0x50, 0x45, 0x52, 0x5f, 0x48, 0x41, 0x4c, 0x46, 0x10, 0x03, 0x12, 0x17, 0x0a, 0x13,
	0x53, 0x45, 0x4c, 0x45, 0x43, 0x54, 0x5f, 0x4d, 0x45, 0x44, 0x49, 0x41, 0x4e, 0x5f, 0x56, 0x41,
	0x4c, 0x55, 0x45, 0x10, 0x04, 0x22, 0x47, 0x0a, 0x19, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c,
	0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x6d, 0x65,
	0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x76, 0x61, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05,
	0x52, 0x04, 0x76, 0x61, 0x72, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x03, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0x53,
	0x0a, 0x16, 0x53, 0x70, 0x61, 0x72, 0x73, 0x65, 0x50, 0x65, 0x72, 0x6d, 0x75, 0x74, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x18, 0x0a, 0x07, 0x73, 0x75, 0x70, 0x70,
	0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x07, 0x73, 0x75, 0x70, 0x70, 0x6f,
	0x72, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0a, 0x63, 0x79, 0x63, 0x6c, 0x65, 0x53, 0x69,
	0x7a, 0x65, 0x73, 0x22, 0x62, 0x0a, 0x10, 0x44, 0x65, 0x6e, 0x73, 0x65, 0x4d, 0x61, 0x74, 0x72,
	0x69, 0x78, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x72,
	0x6f, 0x77, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x6e, 0x75, 0x6d, 0x52, 0x6f,
	0x77, 0x73, 0x12, 0x19, 0x0a, 0x08, 0x6e, 0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6c, 0x73, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x07, 0x6e, 0x75, 0x6d, 0x43, 0x6f, 0x6c, 0x73, 0x12, 0x18, 0x0a,
	0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x05, 0x52, 0x07,
	0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0xad, 0x01, 0x0a, 0x0d, 0x53, 0x79, 0x6d, 0x6d,
	0x65, 0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x53, 0x0a, 0x0c, 0x70, 0x65, 0x72,
	0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x2f, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x53, 0x70, 0x61, 0x72, 0x73, 0x65,
	0x50, 0x65, 0x72, 0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f,
	0x52, 0x0c, 0x70, 0x65, 0x72, 0x6d, 0x75, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x47,
	0x0a, 0x09, 0x6f, 0x72, 0x62, 0x69, 0x74, 0x6f, 0x70, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
	0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72,
	0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x6e, 0x73,
	0x65, 0x4d, 0x61, 0x74, 0x72, 0x69, 0x78, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x09, 0x6f, 0x72,
	0x62, 0x69, 0x74, 0x6f, 0x70, 0x65, 0x73, 0x22, 0x84, 0x05, 0x0a, 0x0c, 0x43, 0x70, 0x4d, 0x6f,
	0x64, 0x65, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x4b, 0x0a, 0x09,
	0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65,
	0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x09,
	0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x4a, 0x0a, 0x0b, 0x63, 0x6f, 0x6e,
	0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28,
	0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65,
	0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61,
	0x69, 0x6e, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x47, 0x0a, 0x09, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69,
	0x76, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73,
	0x61, 0x74, 0x2e, 0x43, 0x70, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50, 0x72,
	0x6f, 0x74, 0x6f, 0x52, 0x09, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x66,
	0x0a, 0x18, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x6f, 0x69, 0x6e, 0x74,
	0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x2c, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65,
	0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74,
	0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52, 0x16,
	0x66, 0x6c, 0x6f, 0x61, 0x74, 0x69, 0x6e, 0x67, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x4f, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x57, 0x0a, 0x0f, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68,
	0x5f, 0x73, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32,
	0x2e, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x63, 0x69, 0x73, 0x69,
	0x6f, 0x6e, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x52,
	0x0e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x53, 0x74, 0x72, 0x61, 0x74, 0x65, 0x67, 0x79, 0x12,
	0x57, 0x0a, 0x0d, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x68, 0x69, 0x6e, 0x74,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69,
	0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74,
	0x2e, 0x50, 0x61, 0x72, 0x74, 0x69, 0x61, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65,
	0x41, 0x73, 0x73, 0x69, 0x67, 0x6e, 0x6d, 0x65, 0x6e, 0x74, 0x52, 0x0c, 0x73, 0x6f, 0x6c, 0x75,
	0x74, 0x69, 0x6f, 0x6e, 0x48, 0x69, 0x6e, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x61, 0x73, 0x73, 0x75,
	0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x05, 0x52, 0x0b, 0x61,
	0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x42, 0x0a, 0x08, 0x73, 0x79,
	0x6d, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x6f,
	0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72,
	0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x53, 0x79, 0x6d, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x08, 0x73, 0x79, 0x6d, 0x6d, 0x65, 0x74, 0x72, 0x79, 0x22, 0x2a,
	0x0a, 0x10, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x6f, 0x6c, 0x75, 0x74, 0x69,
	0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
	0x28, 0x03, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0x95, 0x09, 0x0a, 0x10, 0x43,
	0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
	0x3f, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x27, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73,
	0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76,
	0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73,
	0x12, 0x1a, 0x0a, 0x08, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x03,
	0x28, 0x03, 0x52, 0x08, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x27, 0x0a, 0x0f,
	0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x01, 0x52, 0x0e, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
	0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x30, 0x0a, 0x14, 0x62, 0x65, 0x73, 0x74, 0x5f, 0x6f, 0x62,
	0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x04, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x12, 0x62, 0x65, 0x73, 0x74, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69,
	0x76, 0x65, 0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x5c, 0x0a, 0x14, 0x61, 0x64, 0x64, 0x69, 0x74,
	0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18,
	0x1b, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f,
	0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e,
	0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x13, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x53, 0x6f, 0x6c, 0x75,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5e, 0x0a, 0x13, 0x74, 0x69, 0x67, 0x68, 0x74, 0x65, 0x6e,
	0x65, 0x64, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x73, 0x18, 0x15, 0x20, 0x03,
	0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x6f, 0x70, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f,
	0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e, 0x73, 0x61, 0x74, 0x2e, 0x49, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
	0x6f, 0x52, 0x12, 0x74, 0x69, 0x67, 0x68, 0x74, 0x65, 0x6e, 0x65, 0x64, 0x56, 0x61, 0x72, 0x69,
	0x61, 0x62, 0x6c, 0x65, 0x73, 0x12, 0x57, 0x0a, 0x28, 0x73, 0x75, 0x66, 0x66, 0x69, 0x63, 0x69,
	0x65, 0x6e, 0x74, 0x5f, 0x61, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f,
	0x66, 0x6f, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x65, 0x61, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74,
	0x79, 0x18, 0x17, 0x20, 0x03, 0x28, 0x05, 0x52, 0x25, 0x73, 0x75, 0x66, 0x66, 0x69, 0x63, 0x69,
	0x65, 0x6e, 0x74, 0x41, 0x73, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x46, 0x6f,
	0x72, 0x49, 0x6e, 0x66, 0x65, 0x61, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x12, 0x56,
	0x0a, 0x11, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
	0x69, 0x76, 0x65, 0x18, 0x1c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x6f, 0x70, 0x65, 0x72,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x2e,
	0x73, 0x61, 0x74, 0x2e, 0x43, 0x70, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x52, 0x10, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x4f, 0x62, 0x6a,
	0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x12, 0x3d, 0x0a, 0x1b, 0x69, 0x6e, 0x6e, 0x65, 0x72, 0x5f,
	0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x6c, 0x6f, 0x77, 0x65, 0x72, 0x5f,
	0x62, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x1d, 0x20, 0x01, 0x28, 0x03, 0x52, 0x18, 0x69, 0x6e, 0x6e,
	0x65, 0x72, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x4c, 0x6f, 0x77, 0x65, 0x72,
	0x42, 0x6f, 0x75, 0x6e, 0x64, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x69, 0x6e, 0x74,
	0x65, 0x67, 0x65, 0x72, 0x73, 0x18, 0x1e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6e, 0x75, 0x6d,
	0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f,
	0x62, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b,
	0x6e, 0x75, 0x6d, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x73, 0x12, 0x23, 0x0a, 0x0d, 0x6e,
	0x75, 0x6d, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x6c, 0x69, 0x63, 0x74, 0x73, 0x18, 0x0b, 0x20, 0x01,
	0x28, 0x03, 0x52, 0x0c, 0x6e, 0x75, 0x6d, 0x43, 0x6f, 0x6e, 0x66, 0x6c, 0x69, 0x63, 0x74, 0x73,
	0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x65, 0x73,
	0x18, 0x0c, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6e, 0x75, 0x6d, 0x42, 0x72, 0x61, 0x6e, 0x63,
	0x68, 0x65, 0x73, 0x12, 0x36, 0x0a, 0x17, 0x6e, 0x75, 0x6d, 0x5f, 0x62, 0x69, 0x6e, 0x61, 0x72,
	0x79, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d,
	0x20, 0x01, 0x28, 0x03, 0x52, 0x15, 0x6e, 0x75, 0x6d, 0x42, 0x69, 0x6e, 0x61, 0x72, 0x79, 0x50,
	0x72, 0x6f, 0x70, 0x61, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x38, 0x0a, 0x18, 0x6e,
	0x75, 0x6d, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x5f, 0x70, 0x72, 0x6f, 0x70, 0x61,
	0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x03, 0x52, 0x16, 0x6e,
	0x75, 0x6d, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x65, 0x72, 0x50, 0x72, 0x6f, 0x70, 0x61, 0x67, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x75, 0x6d, 0x5f, 0x72, 0x65, 0x73,
	0x74, 0x61, 0x72, 0x74, 0x73, 0x18, 0x18, 0x20, 0x01, 0x28, 0x03, 0x52, 0x0b, 0x6e, 0x75, 0x6d,
	0x52, 0x65, 0x73, 0x74, 0x61, 0x72, 0x74, 0x73, 0x12, 0x2a, 0x0a, 0x11, 0x6e, 0x75, 0x6d, 0x5f,
	0x6c, 0x70, 0x5f, 0x69, 0x74, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x19, 0x20,
	0x01, 0x28, 0x03, 0x52, 0x0f, 0x6e, 0x75, 0x6d, 0x4c, 0x70, 0x49, 0x74, 0x65, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x77, 0x61, 0x6c, 0x6c, 0x5f, 0x74, 0x69, 0x6d,
	0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x77, 0x61, 0x6c, 0x6c, 0x54, 0x69, 0x6d,
	0x65, 0x12, 0x1b, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x10,
	0x20, 0x01, 0x28, 0x01, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x2d,
	0x0a, 0x12, 0x64, 0x65, 0x74, 0x65, 0x72, 0x6d, 0x69, 0x6e, 0x69, 0x73, 0x74, 0x69, 0x63, 0x5f,
	0x74, 0x69, 0x6d, 0x65, 0x18, 0x11, 0x20, 0x01, 0x28, 0x01, 0x52, 0x11, 0x64, 0x65, 0x74, 0x65,
	0x72, 0x6d, 0x69, 0x6e, 0x69, 0x73, 0x74, 0x69, 0x63, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x21, 0x0a,
	0x0c, 0x67, 0x61, 0x70, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x61, 0x6c, 0x18, 0x16, 0x20,
	0x01, 0x28, 0x01, 0x52, 0x0b, 0x67, 0x61, 0x70, 0x49, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x61, 0x6c,
	0x12, 0x23, 0x0a, 0x0d, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x6e, 0x66,
	0x6f, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x73, 0x6f, 0x6c, 0x75, 0x74, 0x69, 0x6f,
	0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1b, 0x0a, 0x09, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x5f, 0x6c,
	0x6f, 0x67, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x4c,
	0x6f, 0x67, 0x2a, 0x5b, 0x0a, 0x0e, 0x43, 0x70, 0x53, 0x6f, 0x6c, 0x76, 0x65, 0x72, 0x53, 0x74,
	0x61, 0x74, 0x75, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x55, 0x4e, 0x4b, 0x4e, 0x4f, 0x57, 0x4e, 0x10,
	0x00, 0x12, 0x11, 0x0a, 0x0d, 0x4d, 0x4f, 0x44, 0x45, 0x4c, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c,
	0x49, 0x44, 0x10, 0x01, 0x12, 0x0c, 0x0a, 0x08, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c, 0x45,
	0x10, 0x02, 0x12, 0x0e, 0x0a, 0x0a, 0x49, 0x4e, 0x46, 0x45, 0x41, 0x53, 0x49, 0x42, 0x4c, 0x45,
	0x10, 0x03, 0x12, 0x0b, 0x0a, 0x07, 0x4f, 0x50, 0x54, 0x49, 0x4d, 0x41, 0x4c, 0x10, 0x04, 0x42,
	0x40, 0x0a, 0x16, 0x63, 0x6f, 0x6d, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x6f, 0x72,
	0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x2e, 0x73, 0x61, 0x74, 0x42, 0x0f, 0x43, 0x70, 0x4d, 0x6f, 0x64,
	0x65, 0x6c, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x50, 0x01, 0xaa, 0x02, 0x12, 0x47,
	0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x4f, 0x72, 0x54, 0x6f, 0x6f, 0x6c, 0x73, 0x2e, 0x53, 0x61,
	0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_cp_model_proto_rawDescOnce sync.Once
	file_cp_model_proto_rawDescData = file_cp_model_proto_rawDesc
)

func file_cp_model_proto_rawDescGZIP() []byte {
	file_cp_model_proto_rawDescOnce.Do(func() {
		file_cp_model_proto_rawDescData = protoimpl.X.CompressGZIP(file_cp_model_proto_rawDescData)
	})
	return file_cp_model_proto_rawDescData
}

var file_cp_model_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_cp_model_proto_msgTypes = make([]protoimpl.MessageInfo, 29)
var file_cp_model_proto_goTypes = []interface{}{
	(CpSolverStatus)(0), // 0: operations_research.sat.CpSolverStatus
	(DecisionStrategyProto_VariableSelectionStrategy)(0), // 1: operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy
	(DecisionStrategyProto_DomainReductionStrategy)(0),   // 2: operations_research.sat.DecisionStrategyProto.DomainReductionStrategy
	(*IntegerVariableProto)(nil),                         // 3: operations_research.sat.IntegerVariableProto
	(*BoolArgumentProto)(nil),                            // 4: operations_research.sat.BoolArgumentProto
	(*LinearExpressionProto)(nil),                        // 5: operations_research.sat.LinearExpressionProto
	(*LinearArgumentProto)(nil),                          // 6: operations_research.sat.LinearArgumentProto
	(*AllDifferentConstraintProto)(nil),                  // 7: operations_research.sat.AllDifferentConstraintProto
	(*LinearConstraintProto)(nil),                        // 8: operations_research.sat.LinearConstraintProto
	(*ElementConstraintProto)(nil),                       // 9: operations_research.sat.ElementConstraintProto
	(*IntervalConstraintProto)(nil),                      // 10: operations_research.sat.IntervalConstraintProto
	(*NoOverlapConstraintProto)(nil),                     // 11: operations_research.sat.NoOverlapConstraintProto
	(*NoOverlap2DConstraintProto)(nil),                   // 12: operations_research.sat.NoOverlap2DConstraintProto
	(*CumulativeConstraintProto)(nil),                    // 13: operations_research.sat.CumulativeConstraintProto
	(*ReservoirConstraintProto)(nil),                     // 14: operations_research.sat.ReservoirConstraintProto
	(*CircuitConstraintProto)(nil),                       // 15: operations_research.sat.CircuitConstraintProto
	(*RoutesConstraintProto)(nil),                        // 16: operations_research.sat.RoutesConstraintProto
	(*TableConstraintProto)(nil),                         // 17: operations_research.sat.TableConstraintProto
	(*InverseConstraintProto)(nil),                       // 18: operations_research.sat.InverseConstraintProto
	(*AutomatonConstraintProto)(nil),                     // 19: operations_research.sat.AutomatonConstraintProto
	(*ListOfVariablesProto)(nil),                         // 20: operations_research.sat.ListOfVariablesProto
	(*ConstraintProto)(nil),                              // 21: operations_research.sat.ConstraintProto
	(*CpObjectiveProto)(nil),                             // 22: operations_research.sat.CpObjectiveProto
	(*FloatObjectiveProto)(nil),                          // 23: operations_research.sat.FloatObjectiveProto
	(*DecisionStrategyProto)(nil),                        // 24: operations_research.sat.DecisionStrategyProto
	(*PartialVariableAssignment)(nil),                    // 25: operations_research.sat.PartialVariableAssignment
	(*SparsePermutationProto)(nil),                       // 26: operations_research.sat.SparsePermutationProto
	(*DenseMatrixProto)(nil),                             // 27: operations_research.sat.DenseMatrixProto
	(*SymmetryProto)(nil),                                // 28: operations_research.sat.SymmetryProto
	(*CpModelProto)(nil),                                 // 29: operations_research.sat.CpModelProto
	(*CpSolverSolution)(nil),                             // 30: operations_research.sat.CpSolverSolution
	(*CpSolverResponse)(nil),                             // 31: operations_research.sat.CpSolverResponse
}
var file_cp_model_proto_depIdxs = []int32{
	5,  // 0: operations_research.sat.LinearArgumentProto.target:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 1: operations_research.sat.LinearArgumentProto.exprs:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 2: operations_research.sat.AllDifferentConstraintProto.exprs:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 3: operations_research.sat.IntervalConstraintProto.start:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 4: operations_research.sat.IntervalConstraintProto.end:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 5: operations_research.sat.IntervalConstraintProto.size:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 6: operations_research.sat.CumulativeConstraintProto.capacity:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 7: operations_research.sat.CumulativeConstraintProto.demands:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 8: operations_research.sat.ReservoirConstraintProto.time_exprs:type_name -> operations_research.sat.LinearExpressionProto
	5,  // 9: operations_research.sat.ReservoirConstraintProto.level_changes:type_name -> operations_research.sat.LinearExpressionProto
	4,  // 10: operations_research.sat.ConstraintProto.bool_or:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 11: operations_research.sat.ConstraintProto.bool_and:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 12: operations_research.sat.ConstraintProto.at_most_one:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 13: operations_research.sat.ConstraintProto.exactly_one:type_name -> operations_research.sat.BoolArgumentProto
	4,  // 14: operations_research.sat.ConstraintProto.bool_xor:type_name -> operations_research.sat.BoolArgumentProto
	6,  // 15: operations_research.sat.ConstraintProto.int_div:type_name -> operations_research.sat.LinearArgumentProto
	6,  // 16: operations_research.sat.ConstraintProto.int_mod:type_name -> operations_research.sat.LinearArgumentProto
	6,  // 17: operations_research.sat.ConstraintProto.int_prod:type_name -> operations_research.sat.LinearArgumentProto
	6,  // 18: operations_research.sat.ConstraintProto.lin_max:type_name -> operations_research.sat.LinearArgumentProto
	8,  // 19: operations_research.sat.ConstraintProto.linear:type_name -> operations_research.sat.LinearConstraintProto
	7,  // 20: operations_research.sat.ConstraintProto.all_diff:type_name -> operations_research.sat.AllDifferentConstraintProto
	9,  // 21: operations_research.sat.ConstraintProto.element:type_name -> operations_research.sat.ElementConstraintProto
	15, // 22: operations_research.sat.ConstraintProto.circuit:type_name -> operations_research.sat.CircuitConstraintProto
	16, // 23: operations_research.sat.ConstraintProto.routes:type_name -> operations_research.sat.RoutesConstraintProto
	17, // 24: operations_research.sat.ConstraintProto.table:type_name -> operations_research.sat.TableConstraintProto
	19, // 25: operations_research.sat.ConstraintProto.automaton:type_name -> operations_research.sat.AutomatonConstraintProto
	18, // 26: operations_research.sat.ConstraintProto.inverse:type_name -> operations_research.sat.InverseConstraintProto
	14, // 27: operations_research.sat.ConstraintProto.reservoir:type_name -> operations_research.sat.ReservoirConstraintProto
	10, // 28: operations_research.sat.ConstraintProto.interval:type_name -> operations_research.sat.IntervalConstraintProto
	11, // 29: operations_research.sat.ConstraintProto.no_overlap:type_name -> operations_research.sat.NoOverlapConstraintProto
	12, // 30: operations_research.sat.ConstraintProto.no_overlap_2d:type_name -> operations_research.sat.NoOverlap2DConstraintProto
	13, // 31: operations_research.sat.ConstraintProto.cumulative:type_name -> operations_research.sat.CumulativeConstraintProto
	20, // 32: operations_research.sat.ConstraintProto.dummy_constraint:type_name -> operations_research.sat.ListOfVariablesProto
	5,  // 33: operations_research.sat.DecisionStrategyProto.exprs:type_name -> operations_research.sat.LinearExpressionProto
	1,  // 34: operations_research.sat.DecisionStrategyProto.variable_selection_strategy:type_name -> operations_research.sat.DecisionStrategyProto.VariableSelectionStrategy
	2,  // 35: operations_research.sat.DecisionStrategyProto.domain_reduction_strategy:type_name -> operations_research.sat.DecisionStrategyProto.DomainReductionStrategy
	26, // 36: operations_research.sat.SymmetryProto.permutations:type_name -> operations_research.sat.SparsePermutationProto
	27, // 37: operations_research.sat.SymmetryProto.orbitopes:type_name -> operations_research.sat.DenseMatrixProto
	3,  // 38: operations_research.sat.CpModelProto.variables:type_name -> operations_research.sat.IntegerVariableProto
	21, // 39: operations_research.sat.CpModelProto.constraints:type_name -> operations_research.sat.ConstraintProto
	22, // 40: operations_research.sat.CpModelProto.objective:type_name -> operations_research.sat.CpObjectiveProto
	23, // 41: operations_research.sat.CpModelProto.floating_point_objective:type_name -> operations_research.sat.FloatObjectiveProto
	24, // 42: operations_research.sat.CpModelProto.search_strategy:type_name -> operations_research.sat.DecisionStrategyProto
	25, // 43: operations_research.sat.CpModelProto.solution_hint:type_name -> operations_research.sat.PartialVariableAssignment
	28, // 44: operations_research.sat.CpModelProto.symmetry:type_name -> operations_research.sat.SymmetryProto
	0,  // 45: operations_research.sat.CpSolverResponse.status:type_name -> operations_research.sat.CpSolverStatus
	30, // 46: operations_research.sat.CpSolverResponse.additional_solutions:type_name -> operations_research.sat.CpSolverSolution
	3,  // 47: operations_research.sat.CpSolverResponse.tightened_variables:type_name -> operations_research.sat.IntegerVariableProto
	22, // 48: operations_research.sat.CpSolverResponse.integer_objective:type_name -> operations_research.sat.CpObjectiveProto
	49, // [49:49] is the sub-list for method output_type
	49, // [49:49] is the sub-list for method input_type
	49, // [49:49] is the sub-list for extension type_name
	49, // [49:49] is the sub-list for extension extendee
	0,  // [0:49] is the sub-list for field type_name
}

func init() { file_cp_model_proto_init() }
func file_cp_model_proto_init() {
	if File_cp_model_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_cp_model_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntegerVariableProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*BoolArgumentProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearExpressionProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearArgumentProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AllDifferentConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*LinearConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ElementConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IntervalConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NoOverlapConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*NoOverlap2DConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CumulativeConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ReservoirConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CircuitConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RoutesConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TableConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*InverseConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*AutomatonConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListOfVariablesProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ConstraintProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpObjectiveProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FloatObjectiveProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DecisionStrategyProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[22].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PartialVariableAssignment); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[23].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SparsePermutationProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[24].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DenseMatrixProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[25].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*SymmetryProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[26].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpModelProto); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[27].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpSolverSolution); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_cp_model_proto_msgTypes[28].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CpSolverResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_cp_model_proto_msgTypes[18].OneofWrappers = []interface{}{
		(*ConstraintProto_BoolOr)(nil),
		(*ConstraintProto_BoolAnd)(nil),
		(*ConstraintProto_AtMostOne)(nil),
		(*ConstraintProto_ExactlyOne)(nil),
		(*ConstraintProto_BoolXor)(nil),
		(*ConstraintProto_IntDiv)(nil),
		(*ConstraintProto_IntMod)(nil),
		(*ConstraintProto_IntProd)(nil),
		(*ConstraintProto_LinMax)(nil),
		(*ConstraintProto_Linear)(nil),
		(*ConstraintProto_AllDiff)(nil),
		(*ConstraintProto_Element)(nil),
		(*ConstraintProto_Circuit)(nil),
		(*ConstraintProto_Routes)(nil),
		(*ConstraintProto_Table)(nil),
		(*ConstraintProto_Automaton)(nil),
		(*ConstraintProto_Inverse)(nil),
		(*ConstraintProto_Reservoir)(nil),
		(*ConstraintProto_Interval)(nil),
		(*ConstraintProto_NoOverlap)(nil),
		(*ConstraintProto_NoOverlap_2D)(nil),
		(*ConstraintProto_Cumulative)(nil),
		(*ConstraintProto_DummyConstraint)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_cp_model_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   29,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_cp_model_proto_goTypes,
		DependencyIndexes: file_cp_model_proto_depIdxs,
		EnumInfos:         file_cp_model_proto_enumTypes,
		MessageInfos:      file_cp_model_proto_msgTypes,
	}.Build()
	File_cp_model_proto = out.File
	file_cp_model_proto_rawDesc = nil
	file_cp_model_proto_goTypes = nil
	file_cp_model_proto_depIdxs = nil
}
